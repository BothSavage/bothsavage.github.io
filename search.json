[{"title":"手撸Spring源码系列(1)-实现一个简单的Bean容器","url":"/2021/08/11/Spring/手撸Spring源码/手撸Spring源码系列(1)-实现一个简单的Bean容器/","content":"\n## 摘要\n\n* spring定义了一个容器是用来注册，存放，获取Bean对象\n\n<!--more-->\n\n## Bean定义\n\n```java\npublic class BeanDefinition {\n\t\n    //这里直接存放的是对象的引用\n    private Object bean;\n\n    public BeanDefinition(Object bean) {\n        this.bean = bean;\n    }\n\n    public Object getBean() {\n        return bean;\n    }\n\n}\n```\n\n## 容器Bean工厂\n\n```java\npublic class BeanFactory {\n\n    //实际存放的容器\n    private Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n\t\n    //对外暴露的方法：获取bean\n    public Object getBean(String name) {\n        return beanDefinitionMap.get(name).getBean();\n    }\n\t\n    //对外暴露的方法：注册bean定义到容器\n    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) {\n        beanDefinitionMap.put(name, beanDefinition);\n    }\n\n}\n```\n\n## 测试\n\n```java\npublic class ApiTest {\n\n    @Test\n    public void test_BeanFactory(){\n        // 1.初始化 BeanFactory\n        BeanFactory beanFactory = new BeanFactory();\n\n        // 2.注入bean\n        BeanDefinition beanDefinition = new BeanDefinition(new UserService());\n        beanFactory.registerBeanDefinition(\"userService\", beanDefinition);\n\n        // 3.获取bean\n        UserService userService = (UserService) beanFactory.getBean(\"userService\");\n        userService.queryUserInfo();\n    }\n\n}\n```\n\n## 总结\n\n* 工厂中存放的不是具体的对象，而是对象的定义，工厂只存放**生产资料**，我们通过资料的可以去唯一初始化一个对象。\n* 工厂只暴露两个方法，获取bean+注册bean\n\n## 参考\n\n[1].[带你手写 Spring](https://blog.csdn.net/generalfu/category_11066234.html?spm=1001.2014.3001.5482)\n\n[2].[bugstack 虫洞栈](https://bugstack.cn/md/spring/develop-spring/2021-05-16-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Spring%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html)\n\n[3].[《手撸 Spring》 • 小傅哥.pdf](https://download.csdn.net/download/Yao__Shun__Yu/21009038)\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"设计模式(B)-结构型模式概述","url":"/2021/01/03/设计模式/设计模式(B)-结构型模式概述/","content":"## 摘要\n\n* 阐述了结构型模式的作用\n* 阐述了结构型模式的七种分类\n\n<!--more-->\n\n## 简介\n\n关注如何将现有类或对象组织在一起形成更加强大的结构，\n\n它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n\n由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n\n## 分类\n\n1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。\n4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。\n5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n\n> 除了适配器模式分为类结构型和对象结构型模式两种，其他全部都属于对象结构型模式。\n\n## 参考\n\n[1].[结构型模式概述（结构型模式的分类](http://c.biancheng.net/view/1357.html)\n\n[2].[结构型模式_百度百科](https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/23005291?fr=aladdin)\n\n[3].[设计模式 —— 结构型模式](https://www.cnblogs.com/simpleito/p/10878865.html)\n\n","tags":["设计模式","结构型模式","概述"],"categories":["设计模式"]},{"title":"Commit规范和Idea插件","url":"/2021/01/02/杂项/Commit规范和Idea插件/","content":"## 摘要\n\n* 在Idea中安装commit模板信息\n* commit规范模板格式介绍\n<!--more-->\n## 简介\n\n此commit规范是基于augular，规范的编写Commit可以在Idea或者命令行中快速定位修改，或者快速定位问题编号等。\n\n## Idea安装插件\n\n> 插件名称：Git Commit Template\n\n安装完成后在commit框点击如下按钮\n\n![image-20210105175612157](https://gitee.com/BothSavage/PicGo/raw/master/image-20210105175612157.png)\n\n模板展示\n\n![image-20210105181008428](https://gitee.com/BothSavage/PicGo/raw/master/image-20210105181008428.png)\n\n## 格式\n\n### 模板\n\n```bash\n<type>(<scope>): <subject>\n// 空一行\n<body>\n// 空一行\n<footer>\n```\n\n### Header\n\n#### type\n\n- **feat：新功能（feature）**\n- **fix：修补bug**\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动,空格,格式化,等等）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动\n- perf: 性能 (提高代码性能的改变)\n- test：增加测试或者修改测试\n- build: 影响构建系统或外部依赖项的更改(maven,gradle,npm 等等)\n- ci: 对CI配置文件和脚本的更改\n- chore：对非 src 和 test 目录的修改\n- revert: Revert a commit\n\n> 最常用的就是feat和fix\n\n#### scope\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同\n\n#### subject\n\nsubject是 commit 目的的简短描述，不超过50个字符，主要介绍此次代码变更的主要内容\n\n### body\n\n本次commit的详细描述\n\n### footer\n\n* Breaking Changes\n\n  不兼容变动\n\n* Closed issues\n\n  关闭的问题号或者其他指示信息\n\n## 例子\n\n**新增功能** \n\n```\n\nfeat(xxx模块): 增加xx功能\n\n新建了xxxx，增加了xxx功能\n\n```\n\n**修改BUG**\n\n```\n\nfeat(xxx模块): 修复了xx问题\n\n这个问题的原因是xxx，已经更改xxx文件中的xxx代码，本地测试通过\n\nCloses #1234\n\n```\n\n\n\n## 参考\n\n[1].[Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\n[2].[Git Commit提交规范和IDEA插件Git Commit Template的使用](https://blog.csdn.net/qq_35854212/article/details/103856299)\n\n","tags":["工具","idea","git"],"categories":["杂项"]},{"title":"设计模式(1)-单例模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(1)-单例模式/","content":"## 摘要\n\n* 简单介绍了什么是单例模式\n* 介绍了懒汉式和饿汉式的实现\n* 分析了单例模式出现的场景\n* 用数据库连接池的例子演示了单例模式\n\n\n<!--more-->\n\n## 概念\n\n确保一个类只能有一个实例，并提供一个全局访问点来访问这个实例。\n\n### 要点\n\n* 某一个类只能创建一个一个实例\n* 必须类内部自行创建这个实例\n* 必须向系统提供这个实例，也就是提供一个全局访问点\n\n### 优点\n\n* 保证内存中只有一个实例，减小内存开销\n* 避免对资源的多重占用\n* 设置全局访问点，优化和共享资源的访问\n\n### 缺点\n\n* 扩展困难，如果要扩展除了修改原来的代码没有第二种开发途径，违背开闭原则\n* 单例模式的功能通常都写在一个类中，如果功能设计不合理，则很容易违反单一职责原则\n* 并发测试中不好debug\n\n## 场景\n\n对于Java来说，单例模式的落地就是在JVM中只存在单一实例。\n\n* 需要频繁创建一些类，使用单例可以降低系统的内存压力，减少GC\n* 某类只要求生成一个对象的时候，比如一个班中的班长，一个人的身份证\n\n- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。\n- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如**多线程的线程池、网络连接池**等。\n- 频繁访问数据库或文件的对象。\n- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。\n- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 **Web 中的配置对象、数据库的连接池**等。\n\n## 实现方式\n\n懒汉式\n\n每次访问都需要同步，会影响性能，且消耗更多的资源，这就是懒汉式的缺点\n\n```java\npublic class Lazy{\n    private static volatile Lazy instance;\n    private Lazy(){}\n    //DLC\n    public static getInstance(){\n        if(instance==null){\n            synchronized(Lazy.class){\n                if(instance==null){\n                    instance = new Lazy();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n饿汉式\n\n```java\npublic class Hungry{\n    private static final Hungry instance = new Hungry();\n    private Hungry() {}\n    public static Hungry getInstance() {\n        return instance;\n    }\n}\n```\n\n## 实例\n\n获取数据库连接池\n\n```java\npublic final class DbConnectConfig {\n \n    private static ComboPooledDataSource dataSource;\n \n    static {\n        dataSource = new ComboPooledDataSource();\n        dataSource.setUser(JdbcPropertiesConfig.getUSERNAME());\n        dataSource.setPassword(JdbcPropertiesConfig.getPASSWORD());\n        dataSource.setJdbcUrl(JdbcPropertiesConfig.getDATABASEURL());\n        dataSource.setDriverClass(xxxxxxx);\n        //初始化连接数\n        dataSource.setInitialPoolSize(xxx.getINITIALPOOLSIZE());\n        //最小连接数\n        dataSource.setMinPoolSize(xxx.getMINPOOLSIZE());\n        //最大连接数\n        dataSource.setMaxPoolSize(xxx.getMAXPOOLSIZE());\n        //最长等待时间\n        dataSource.setMaxStatements(xxx.getMAXSTATEMENTS());\n        //最大空闲时间，单位毫秒\n        dataSource.setMaxIdleTime(xxx.getMAXIDLETIME());\n        dataSource.setCheckoutTimeout(5000);\n        dataSource.setUnreturnedConnectionTimeout(20);\n    }\n \n \t//这里使用DLC好一点\n    public synchronized static final Connection getConnection() {\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n        } catch (SQLException e) {\n            System.out.println(\"\\r\\n数据库连接异常\");\n            e.printStackTrace();\n        }\n        return conn;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[单例模式设置mysql数据库连接池](https://blog.csdn.net/sade1231/article/details/81562156)\n\n[2].[单例模式（单例设计模式）详解](http://c.biancheng.net/view/1338.html)\n\n[3].[学习笔记 : Java设计模式之Singleton Pattern](https://ishacker.net/2019/09/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton-Pattern/)\n\n","tags":["demo","设计模式","单例模式"],"categories":["设计模式"]},{"title":"设计模式(2)-原型模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(2)-原型模式/","content":"## 摘要\n\n* 介绍了原型模式的概念\n* 原型模式的优点就是性能比new好\n* 对比了深浅拷贝\n\n<!--more-->\n## 概念\n\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 \n\n### 优点\n\n* Java自带的原型模式基于内存二进制流的复制（此时访问权限对原型模式无效），在性能上比直接 new 一个对象更加优良，克隆不会执行构造方法，避免了初始化占有的时间和空间 \n\n### 缺点\n\n* 需要为每一个类都配置一个 clone 方法\n* clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。\n* 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。\n\n## 场景\n\n- 对象之间相同或相似，即只是个别的几个属性不同的时候。\n- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。\n- 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。\n- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。\n\n> 在 Spring中，原型模式应用的非常广泛，例如 scope='prototype'、JSON.parseObject() 等都是原型模式的具体应用。\n\n## 实例\n\n### 浅克隆\n\n```java\npublic class Brand {\n\tpublic void install(){\n\t\tSystem.out.println(\"安装汽车品牌\");\n\t}\n}\n```\n\n```java\n@Data\npublic class Car implements Cloneable{\n\tprivate Brand brand;\n\t\n\tpublic Car(){\n\t\tthis.brand = new Brand();\n\t}\n\t\n\t@Override\n\tprotected Object clone() {\n\t\tCar clone = null;\n\t\ttry {\n\t\t\tclone = (Car)super.clone();\n\t\t} catch (CloneNotSupportedException e) {\n\t\t\tSystem.out.println(\"克隆失败...\");\n\t\t}\n\t\treturn clone;\n\t}\n\t\n\t\n\tpublic void run(){\n\t\tSystem.out.println(\"小汽车能跑了\");\n\t}\n}\n\n```\n\n```java\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCar car,cloneCar;\n\t\tcar = new Car();\n\t\tcloneCar = (Car)car.clone();\n\t\t\n\t\tSystem.out.println(\"car == cloneCar?\");\n\t\tSystem.out.println(car == cloneCar);\n\t\t\n\t\tSystem.out.println(\"car.getBrand() == cloneCar.getBrand()?\");\n\t\tSystem.out.println(car.getBrand() == cloneCar.getBrand());\n\t}\n}\n\n```\n\n### 深克隆\n\n```java\npublic class Brand implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic void install(){\n\t\tSystem.out.println(\"安装汽车品牌\");\n\t}\n}\n\n```\n\n```java\n@Data\npublic class Car implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\tprivate Brand brand = null;\n\t\n\tpublic Car(){\n\t\tthis.brand = new Brand();\n\t}\n\t\n\tpublic Object deepClone() throws IOException, ClassNotFoundException{\n\t\t//将对象写入流中\n\t\tByteArrayOutputStream bao=new ByteArrayOutputStream();\n\t\tObjectOutputStream oos=new ObjectOutputStream(bao);\n\t\toos.writeObject(this);\n\t\t\t\t\n\t\t//将对象从流中取出\n\t\tByteArrayInputStream bis=new ByteArrayInputStream(bao.toByteArray());\n\t\tObjectInputStream ois=new ObjectInputStream(bis);\n\t\treturn(ois.readObject());\n\t}\n\tpublic void run(){\n\t\tSystem.out.println(\"小汽车能跑了\");\n\t}\n}\n\n```\n\n```java\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCar car,cloneCar=null;\n\t\tcar = new Car();\n\t\ttry {\n\t\t\tcloneCar = (Car) car.deepClone();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tSystem.out.println(\"car == cloneCar?\");\n\t\tSystem.out.println(car == cloneCar);\n\t\t\n\t\tSystem.out.println(\"car.getBrand() == cloneCar.getBrand()?\");\n\t\tSystem.out.println(car.getBrand() == cloneCar.getBrand());\n\t}\n}\n```\n\n\n\n## 参考\n\n[1].[原型模式（原型设计模式）详解](http://c.biancheng.net/view/1343.html)\n\n[2].[原型模式](https://www.runoob.com/design-pattern/prototype-pattern.html)\n\n[3].[设计模式之原型模式（Java代码实现）](https://baijiahao.baidu.com/s?id=1639108556663038986&wfr=spider&for=pc)\n\n[4].[原型模式（实例）](https://blog.csdn.net/qq_44889069/article/details/106151467)\n\n\n\n","tags":["demo","设计模式","原型模式"],"categories":["设计模式"]},{"title":"设计模式(3)-简单工厂模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(3)-简单工厂模式/","content":"## 摘要\n\n* 简单介绍了什么是简单工厂模式\n* 简单工厂实例\n<!--more-->\n## 概念\n\n> **简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。**\n>\n> 简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。\n\n### 优点\n\n* 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。\n* 客户端无需知道所创建具体产品的类名，只需知道参数即可。\n* 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。\n\n### 缺点\n\n1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。\n2. 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度\n3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂\n4. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。\n\n## 场景\n\n* 产品种类较少的模式\n* 简单工厂模式的客户端只需要传入工厂类的参数，不用关心对象的创建逻辑\n\n## 实现\n\n### 抽象产品\n\n```java\npublic interface Product {\n     void show();\n}\n```\n\n### 具体产品\n\n```java\nclass ConcreteProduct1 implements Product {\n    public void show() {\n    \tSystem.out.println(\"具体产品1显示...\");\n    }\n}\n```\n\n```java\nclass ConcreteProduct2 implements Product {\n    public void show() {\n    \tSystem.out.println(\"具体产品1显示...\");\n    }\n}\n```\n\n```java\nclass SimpleFactory {\n    public static Product makeProduct(int kind) {\n        switch (kind) {\n            case Const.PRODUCT_A:\n                return new ConcreteProduct1();\n            case Const.PRODUCT_B:\n                return new ConcreteProduct2();\n        }\n        return null;\n    }\n}\n\n//辅助常量\nfinal class Const {\n    static final int PRODUCT_A = 0;\n    static final int PRODUCT_B = 1;\n    static final int PRODUCT_C = 2;\n}\n```\n\n## 参考\n\n[1].[简单工厂模式](http://c.biancheng.net/view/8385.html)\n\n[2].[工厂模式--简单工厂模式](https://www.jianshu.com/p/5cb52d84bd6d)\n\n","tags":["demo","设计模式","工厂模式"],"categories":["设计模式"]},{"title":"设计模式(6)-建造者模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(6)-建造者模式/","content":"## 摘要\n\n* 简单介绍了什么是建造者模式\n* 菜鸟教程的小例子\n<!--more-->\n## 概念\n\n> 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\n\n\n\n建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。\n\n### 优点\n\n* 封装性好，构建和表示分离。\n* 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。\n* 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。\n\n### 缺点\n\n* 产品的组成部分必须相同，这限制了其使用范围。\n* 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大\n\n## 场景\n\n* **当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。**\n* 需要生成的对象具有复杂的内部结构\n* 需要生成的对象内部属性本身相互依赖\n\n## 实例\n\n### 文字实例\n\n* 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"\n\n* JAVA 中的 StringBuilder'\n\n### 代码实例\n\n#### 食物条目接口\n\n```java\npublic interface Item {\n   public String name();\n   public Packing packing();\n   public float price();    \n}\n```\n\n#### 食物包装接口\n\n```java\npublic interface Packing {\n   public String pack();\n}\n```\n\n#### 包装接口实体\n\n```java\npublic class Wrapper implements Packing {\n \n   @Override\n   public String pack() {\n      return \"Wrapper\";\n   }\n}\n```\n\n```java\npublic class Bottle implements Packing {\n \n   @Override\n   public String pack() {\n      return \"Bottle\";\n   }\n}\n```\n\n#### 食物条目接口抽象类\n\n```java\npublic abstract class Burger implements Item {\n \n   @Override\n   public Packing packing() {\n      return new Wrapper();\n   }\n \n   @Override\n   public abstract float price();\n}\n```\n\n```java\npublic abstract class ColdDrink implements Item {\n \n    @Override\n    public Packing packing() {\n       return new Bottle();\n    }\n \n    @Override\n    public abstract float price();\n}\n```\n\n#### 食物条目实体\n\n```java\npublic class VegBurger extends Burger {\n \n   @Override\n   public float price() {\n      return 25.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Veg Burger\";\n   }\n}\n```\n\n```java\npublic class ChickenBurger extends Burger {\n \n   @Override\n   public float price() {\n      return 50.5f;\n   }\n \n   @Override\n   public String name() {\n      return \"Chicken Burger\";\n   }\n}\n```\n\n```java\npublic class Coke extends ColdDrink {\n \n   @Override\n   public float price() {\n      return 30.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Coke\";\n   }\n}\n```\n\n```java\npublic class Pepsi extends ColdDrink {\n \n   @Override\n   public float price() {\n      return 35.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Pepsi\";\n   }\n}\n```\n\n#### 菜单实体\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Meal {\n   private List<Item> items = new ArrayList<Item>();    \n \n   public void addItem(Item item){\n      items.add(item);\n   }\n \n   public float getCost(){\n      float cost = 0.0f;\n      for (Item item : items) {\n         cost += item.price();\n      }        \n      return cost;\n   }\n \n   public void showItems(){\n      for (Item item : items) {\n         System.out.print(\"Item : \"+item.name());\n         System.out.print(\", Packing : \"+item.packing().pack());\n         System.out.println(\", Price : \"+item.price());\n      }        \n   }    \n}\n```\n\n#### 实体构造者对象\n\n```java\npublic class MealBuilder {\n \n   public Meal prepareVegMeal (){\n      Meal meal = new Meal();\n      meal.addItem(new VegBurger());\n      meal.addItem(new Coke());\n      return meal;\n   }   \n \n   public Meal prepareNonVegMeal (){\n      Meal meal = new Meal();\n      meal.addItem(new ChickenBurger());\n      meal.addItem(new Pepsi());\n      return meal;\n   }\n}\n```\n\n#### 演示\n\n```java\npublic class BuilderPatternDemo {\n   public static void main(String[] args) {\n      MealBuilder mealBuilder = new MealBuilder();\n \n      Meal vegMeal = mealBuilder.prepareVegMeal();\n      System.out.println(\"Veg Meal\");\n      vegMeal.showItems();\n      System.out.println(\"Total Cost: \" +vegMeal.getCost());\n \n      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();\n      System.out.println(\"\\n\\nNon-Veg Meal\");\n      nonVegMeal.showItems();\n      System.out.println(\"Total Cost: \" +nonVegMeal.getCost());\n   }\n}\n```\n\n\n\n## 参考\n\n[1].[秒懂设计模式之建造者模式（Builder pattern）](https://zhuanlan.zhihu.com/p/58093669)\n\n[2].[建造者模式（Bulider模式）详解](http://c.biancheng.net/view/1354.html)\n\n[3].[建造者模式](https://www.runoob.com/design-pattern/builder-pattern.html)\n\n","tags":["demo","设计模式","建造者模式"],"categories":["设计模式"]},{"title":"设计模式(5)-抽象工厂模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(5)-抽象工厂模式/","content":"## 摘要\n\n* 简单介绍了额超级工厂(抽象工厂)的概念\n* 实现一个小Demo\n<!--more-->\n## 概念\n\n> 是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。\n>\n\n### 优点\n\n* 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\n* 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。\n* 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。\n\n### 缺点\n\n* 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。\n\n## 场景\n\n- 创建对象的最佳方式\n\n## 实例\n\n### 抽象产品A\n\n```java\npublic interface ProductA {\n   void do();\n}\n```\n\n### 抽象产品A实现A,B,C\n\n```java\npublic class ProductAImplA implements ProductA {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductAImplA\");\n   }\n}\n```\n\n```java\npublic class ProductAImplB implements ProductA {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductAImplB\");\n   }\n}\n```\n\n```java\npublic class ProductAImplC implements ProductA {\n \n   @Override\n   public void do() {\n      System.out.println(\"IProductAImplC\");\n   }\n}\n```\n\n### 抽象产品B\n\n```java\npublic interface ProductB {\n   void do();\n}\n```\n\n### 抽象产品B实现A,B,C\n\n```java\npublic class ProductBImplA implements ProductB {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductBImplA\");\n   }\n}\n```\n\n```java\npublic class ProductBImplB implements ProductB {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductBImplB\");\n   }\n}\n```\n\n```java\npublic class ProductBImplC implements ProductB {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductBImplC\");\n   }\n}\n```\n\n### 抽象工厂\n\n```java\npublic abstract class AbstractFactory {\n   public abstract ProductA getProductA(String name);\n   public abstract ProductB getProductB(String name) ;\n}\n```\n\n### 工厂实例\n\n```java\npublic class ProductAFactory extends AbstractFactory {\n    \n   @Override\n   public Shape getProductA(String name){\n      if(name == null){\n         return null;\n      }        \n      if(name.equalsIgnoreCase(\"getProductAImplA\")){\n         return new getProductAImplA();\n      } else if(name.equalsIgnoreCase(\"getProductAImplB\")){\n         return new getProductAImplB();\n      } else if(name.equalsIgnoreCase(\"getProductAImplC\")){\n         return new getProductAImplC();\n      }\n      return null;\n   }\n   \n   @Override\n   public Color getProductB(String name) {\n      return null;\n   }\n}\n```\n\n```java\npublic class ProductBFactory extends AbstractFactory {\n    \n   @Override\n   public Shape getProductA(String name){\n      return null;\n   }\n   \n   @Override\n   public Color getProductB(String name) {\n      if(name == null){\n         return null;\n      }        \n      if(name.equalsIgnoreCase(\"getProductBImplA\")){\n         return new getProductBImplA();\n      } else if(name.equalsIgnoreCase(\"getProductBImplB\")){\n         return new getProductBImplB();\n      } else if(name.equalsIgnoreCase(\"getProductBImplC\")){\n         return new getProductBImplC();\n      }\n      return null;\n   }\n}\n```\n\n### 工厂创造器\n\n```java\npublic class FactoryProducer {\n   public static AbstractFactory getFactory(String choice){\n      if(choice.equalsIgnoreCase(\"ProductAFactory\")){\n         return new ProductAFactory();\n      } else if(choice.equalsIgnoreCase(\"ProductBFactory\")){\n         return new ProductBFactory();\n      }\n      return null;\n   }\n}\n```\n\n## 参考\n\n[1].[抽象工厂模式](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)\n\n[2].[抽象工厂模式（详解版）](http://c.biancheng.net/view/1351.html)\n\n[3].[抽象工厂模式和工厂模式的区别？](https://www.zhihu.com/question/20367734)\n\n\n\n","tags":["demo","设计模式","工厂模式"],"categories":["设计模式"]},{"title":"设计模式(4)-工厂方法模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(4)-工厂方法模式/","content":"## 摘要\n\n* 工厂方法模式就是把工厂也做抽象\n* 一个工厂方法模式的小实例\n<!--more-->\n## 概念\n\n> 对简单工厂方式的进一步抽象，在不改变原来的代码情况下去引入新的产品，满足开闭原则\n\n### 优点\n\n* 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。\n* 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。\n* 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。\n\n### 缺点\n\n* 类的个数容易过多，增加复杂度\n* 增加了系统的抽象性和理解难度\n* 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。\n\n## 场景\n\n* 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。\n* 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。\n* 客户不关心创建产品的细节，只关心产品的品牌\n\n## 实例\n\n### 产品的抽象\n\n```java\ninterface Product {\n    public void show();\n}\n```\n### 产品的实现\n\n```java\nclass ConcreteProduct1 implements Product {\n    public void show() {\n        System.out.println(\"具体产品1显示...\");\n    }\n}\n\nclass ConcreteProduct2 implements Product {\n    public void show() {\n        System.out.println(\"具体产品2显示...\");\n    }\n}\n```\n### 工厂的抽象\n```java\ninterface AbstractFactory {\n    public Product newProduct();\n}\n```\n### 工厂的实现\n```java\nclass ConcreteFactory1 implements AbstractFactory {\n    public Product newProduct() {\n        System.out.println(\"具体工厂1生成-->具体产品1...\");\n        return new ConcreteProduct1();\n    }\n}\n\nclass ConcreteFactory2 implements AbstractFactory {\n    public Product newProduct() {\n        System.out.println(\"具体工厂2生成-->具体产品2...\");\n        return new ConcreteProduct2();\n    }\n}\n```\n\n## 扩展\n\n> * 简单工厂模式就是只有一个产品，不需要多余的工厂\n> * 在多个产品种类的需求下，为每一种产品定义一种工厂类\n\n## 参考\n\n[1].[工厂方法模式（详解版）](http://c.biancheng.net/view/1348.html)\n\n[2].[设计模式之工厂方法模式](https://blog.csdn.net/weixin_40388441/article/details/109493785)","tags":["demo","设计模式","工厂模式"],"categories":["设计模式"]},{"title":"设计模式(0)-入门","url":"/2020/12/30/设计模式/设计模式(0)-入门/","content":"## 摘要\n\n* 简述了设计模式是什么以及优点\n* 按照目的和作用范围进行了划分\n* 介绍了23种设计模式\n\n\n<!--more-->\n\n## 简介\n\n目前软件工程的设计模式主要是23种，可以根据模式的目的和模式的作用范围进行分类。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性以及类之间的关联关系和组合关系的充分理解。\n\n优点\n\n* 思维能力，编程能力，设计能力\n* 设计标准化，代码编制工程化\n* 保证代码可重复用性，可读性，可靠性，灵活性，可维护性\n\n## 分类\n\n* 目的划分\n  * 创建型模式\n    * 将对象的创建与使用分离\n    * 五种创建模式\n      * 单例\n      * 原型\n      * 工厂方法\n      * 抽象工厂\n      * 建造者\n  * 结构型模式\n    * 描述如何将类或对象以某种布局组成更大的结构\n    * 七种结构型模式\n      * 代理\n      * 适配器\n      * 桥接\n      * 装饰\n      * 外观\n      * 享元\n      * 组合\n  * 行为型模式\n    * 描述类或者对象之间相互协作共同完成单个对象无法完成的任务，以及职责划分\n    * 十一种行为型模式\n      * 模板方法\n      * 策略\n      * 命令\n      * 职责链\n      * 状态\n      * 观察者\n      * 中介者\n      * 迭代器\n      * 访问者\n      * 备忘录\n      * 解释器\n* 作用范围划分\n  * 类模式\n    * 处理类和子类的关系，这些关系通过继承来建立，是静态的，编译时刻就稳定下来了\n    * 四种类模式\n      * (类)适配器\n      * 模板方法\n      * 解释器\n      * 工厂方法\n  * 对象模式\n    * 用于处理对象之间的关系，这些关系可以通过组合或者聚合来实现，在运行时刻是可以变化的具有动态性\n    * 十九种对象模式\n\n## 具体介绍\n\n1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。\n10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。\n18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n## 参考\n\n[1].[GoF 的 23 种设计模式的分类和功能](http://c.biancheng.net/view/1320.html)\n\n[2].[软件设计模式概述](http://c.biancheng.net/view/1317.html)\n\n\n\n","tags":["设计模式","入门"],"categories":["设计模式"]},{"title":"SpringBoot系列(1)——AOP-3-实战1-权限&日志","url":"/2020/12/29/SpringBoot/SpringBoot系列(1)——AOP-3-实战1-权限&日志/","content":"## 摘要\n\n* 实现简单的权限控制\n* 实现简单的日志\n\n\n<!--more-->\n\n## 权限控制\n\n### pom\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface PermissionAnnotation{}\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\n@Order(1)\npublic class PermissionFirstAdvice {\n\n    @Pointcut(\"@annotation(xx.xx.xx.PermissionAnnotation)\")\n    private void permissionCheck() {\n    }\n\n    @Around(\"permissionCheck()\")\n    public Object permissionCheckFirst(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(System.currentTimeMillis());\n\n        //获取请求参数\n        Object[] objects = joinPoint.getArgs();\n        String userName = (String) objects[0];\n\n        if (!userName.equals(\"admin\")) {\n            return \"失败\";\n        }\n        return joinPoint.proceed();\n    }\n}\n```\n\n### controller\n\n```java\n@RestController\n@RequestMapping(value = \"/permission\")\npublic class TestController {\n    \n    @RequestMapping(value = \"/check\", method = RequestMethod.POST)\n    @PermissionsAnnotation()\n    public String getGroupList(@RequestParam String userName) {\n        return \"Hello \"+userName;\n    }\n}\n```\n\n## 日志\n\n### pom\n\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.5.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.70</version>\n        </dependency>\n    </dependencies>\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\npublic class OperLogAspect {\n\n    //操作切入点\n    @Pointcut(\"@annotation(com.bothsavage.annotation.OperLog)\")\n    public void operLogPoinCut() {}\n\n\n    //正常返回通知\n    @AfterReturning(value = \"operLogPoinCut()\", returning = \"keys\")\n    public void saveOperLog(JoinPoint joinPoint, Object keys) {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);\n        OperationLog operlog = new OperationLog();\n        try {\n            MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n            Method method = signature.getMethod();\n            String className = joinPoint.getTarget().getClass().getName();\n            String methodName = method.getName();\n            OperLog opLog = method.getAnnotation(OperLog.class);\n            methodName = className + \".\" + methodName;\n            Map<String, String> rtnMap = converMap(request.getParameterMap());\n            String params = JSON.toJSONString(rtnMap);\n\n            operlog.setOperId(IdUtil.randomUUID());\n            operlog.setOperModul(opLog.operModul());\n            operlog.setOperType(opLog.operType());\n            operlog.setOperDesc(opLog.operDesc());\n            operlog.setOperMethod(methodName); // 请求方法\n            operlog.setOperRequParam(params); // 请求参数\n            operlog.setOperRespParam(JSON.toJSONString(keys)); // 返回结果\n            operlog.setOperUri(request.getRequestURI()); // 请求URI\n            operlog.setOperCreateTime(new Date()); // 创建时间\n\n            //打印日志\n            System.out.println(JSON.toJSONString(operlog));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n        //转换request 请求参数\n    public Map<String, String> converMap(Map<String, String[]> paramMap) {\n        Map<String, String> rtnMap = new HashMap<String, String>();\n        for (String key : paramMap.keySet()) {\n            rtnMap.put(key, paramMap.get(key)[0]);\n        }\n        return rtnMap;\n    }\n\n    //转换异常信息为字符串\n    public String stackTraceToString(String exceptionName, String exceptionMessage, StackTraceElement[] elements) {\n        StringBuffer strbuff = new StringBuffer();\n        for (StackTraceElement stet : elements) {\n            strbuff.append(stet + \"\\n\");\n        }\n        String message = exceptionName + \":\" + exceptionMessage + \"\\n\\t\" + strbuff.toString();\n        return message;\n    }\n}\n```\n\n### 实体类\n\n```java\npackage com.bothsavage.entity;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\npublic class OperationLog {\n    private String operId;\n    private String operModul;\n    private String operType;\n    private String operDesc;\n    private String OperMethod;\n    private String OperRequParam;\n    private String OperRespParam;\n    private String OperUserId;\n    private String OperUserName;\n    private String OperIp;\n    private String OperUri;\n    private Date OperCreateTime;\n    private String OperVer;\n}\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD) //注解放置的目标位置,METHOD是可注解在方法级别上\n@Retention(RetentionPolicy.RUNTIME) //注解在哪个阶段执行\n@Documented\npublic @interface OperLog {\n    String operModul() default \"\"; // 操作模块\n    String operType() default \"\";  // 操作类型\n    String operDesc() default \"\";  // 操作说明\n}\n```\n\n### controller\n\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/test/{testName}\")\n    @OperLog(operModul = \"测试模块\",operType = \"test\",operDesc = \"这个是用来测试的\")\n    public String test(@PathVariable String testName){\n        return  \"hello\"+testName;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[把自己牛逼到了，在SpringBoot用AOP切面实现一个权限校验...](https://mp.weixin.qq.com/s/2e8x9n4p49kZzM2Fr2cTVw)\n\n[2].[Spring AOP 实现功能权限校验功能](https://blog.csdn.net/houxuehan/article/details/51745175?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&spm=1001.2101.3001.4242)\n\n[3].[SpringAop实现权限校验与日志打印](https://blog.csdn.net/sinat_34620530/article/details/103993158?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control)\n\n[4].[基于Spring AOP实现的权限控制](https://www.cnblogs.com/sxkgeek/p/9985929.html)\n\n[5].[使用SpringBoot AOP 记录操作日志、异常日志](https://www.cnblogs.com/wm-dv/p/11735828.html)\n\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(1)——AOP-2-静态代理与动态代理","url":"/2020/12/29/SpringBoot/SpringBoot系列(1)——AOP-2-静态代理与动态代理/","content":"## 摘要\n\n* 分别演示静态代理和动态代理\n\n<!--more-->\n\n## 静态代理\n\n### 手动代理\n\n#### interface\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 代理类\n\n```java\npublic class Object_Agent implements Interface_{\n\n    private Object_ object_;\n    public Object_Agent(Object_ object_) {\n        this.object_ = object_;\n    }\n\n    @Override\n    public  void do() {\n        System.out.println(\"enhance\");\n        object_.do();\n    }\n    \n    public static void main(String[] args) {\n        Object_ object_ = new Object_();\n        Object_Agent agent = new Object_Agent(object_);\n        agent.do();\n    }\n\n}\n```\n\n\n\n### AspectJ静态\n\n* 编写方式和spring aop没有区别\n\n- Aspectj并不是动态的在运行时生成代理类，而是在编译的时候就植入代码到class文件\n- 由于是静态织入的，所以性能相对来说比较好\n\n\n\n## 动态代理\n\n> * JDK动态代理是基于接口的方式，代理类和目标类都实现同一个接口。\n> * CGLib动态代理是代理类去继承目标类，然后重写其中目标类的方法。\n\n### JDK动态代理\n\n#### 接口\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 处理器实现类\n\n```java\npublic class InvocationHandlerImpl implements InvocationHandler{\n\n    private Object object;\n    public InvocationHandlerImpl(Object object)\n    {\n        this.object = object;\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n    {\n        System.out.println(\"enhance\");\n        Object object = method.invoke(object, args);\n        return object;\n    }\n}\n```\n\n#### 测试\n\n```java\npublic class DynamicProxyDemonstration\n{\n    public static void main(String[] args)\n    {\n        Interface_ object_ = new Object_();\n        InvocationHandler handler = new InvocationHandlerImpl(object_);\n        ClassLoader loader = object_.getClass().getClassLoader();\n        Class[] interfaces = object_.getClass().getInterfaces();\n        Interface_ object__ = (Interface_) Proxy.newProxyInstance(loader, interfaces, handler); \n        object__.do();\n    }\n \n}\n```\n\n\n\n### CGlib动态代理\n\n#### POM\n\n```xml\n<dependency>\n        <groupId>cglib</groupId>\n        <artifactId>cglib</artifactId>\n        <version>2.2.2</version>\n</dependency>\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_{\n    public  void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 方法拦截器\n\n```java\npublic class MyMethodInterceptor implements MethodInterceptor{\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"enhance\");\n        Object object = proxy.invokeSuper(obj, args);\n        return object;\n    }  \n}\n```\n\n#### 测试\n\n```java\npublic class CgLibProxy {\n    public static void main(String[] args) {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer = new Enhancer();\n        //设置目标类的字节码文件\n        enhancer.setSuperclass(Object_.class);\n        //设置回调函数\n        enhancer.setCallback(new MyMethodInterceptor());\n        //创建加运行\n        Object_ proxyObject_ = (Object_)enhancer.create();\n        proxyObject_.do();       \n    }\n}\n```\n\n## 为啥转变被CGlib\n\n一般写代码：\n\n```java\n@Autowired\nUserService userService;\n```\n\n出错代码：\n\n```\n@Autowired\nUserServiceImpl userService;\n```\n\n![启动报错](https://img2018.cnblogs.com/blog/1822265/201910/1822265-20191029133357222-1265293381.png)\n\n JDK 动态代理是基于接口的，代理生成的对象只能赋值给接口变量。\n\n而 CGLIB 就不存在这个问题。因为 CGLIB 是通过生成子类来实现的，代理对象无论是赋值给接口还是实现类这两者都是代理对象的父类。\n\n## 总结\n\n* Spring5 默认aop实现为CGlib\n* JDK动态代理是基于接口的，CGlib动态代理是基于继承的\n\n## 参考\n\n[1].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[2].[java反射和代理](https://www.cnblogs.com/wyq1995/p/10936286.html)\n\n[3].[惊人！Spring5 AOP 默认使用Cglib? 从现象到源码深度分析](https://www.cnblogs.com/coderxiaohei/p/11758239.html)","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(1)——AOP-1-入门","url":"/2020/12/28/SpringBoot/SpringBoot系列(1)——AOP-1-入门/","content":"\n## 摘要\n\n* aop关键词\n* spring aop小demo\n\n<!--more-->\n\n## 概念\n\n> 使用场景：与业务无关的且经常使用到的公共功能如鉴权，日志，性能优化，事务，错误处理，资源池，同步，审计，幂等等\n\n>  优点：降低耦合度，易扩展，高复用\n>\n>  实现方式：静态代理(AspectJ) + 动态代理（CGlib/Jdk）\n\n### aop关键词\n\n- 连接点(Joinpoint):连接点就是增强的实现\n- 切点(PointCut):就是那些需要应用切面的方法 \n- 增强(Advice)\n  - 前置通知(before)\n  - 后置通知(after)\n  - 异常通知(afterThrowing)\n  - 返回通知(afterReturning)\n  - 环绕通知(around)\n- 目标对象(Target)\n- 织入(Weaving):添加到对目标类具体连接点上的过程。\n- 代理类(Proxy):一个类被AOP织入增强后，就产生了一个代理类。\n- 切面(Aspect):切面由切点和增强组成，它既包括了横切逻辑的定义，也包括了连接点的定义\n  ![](https://gitee.com/BothSavage/PicGo/raw/master/image/20210102170844.png)\n### 五种返回类型\n\n* @Before： 标识一个前置增强方法，相当于BeforeAdvice的功能. \n* @After： final增强，不管是抛出异常或者正常退出都会执行. \n* @AfterReturning： 后置增强，似于AfterReturningAdvice, 方法正常退出时执行.\n*  @AfterThrowing： 异常抛出增强，相当于ThrowsAdvice. @Around： 环绕增强，相当于MethodInterceptor. \n\n### 连接点限制\n\n- 任意公共方法的执行：execution(public * *(..))\n- 任何一个以“set”开始的方法的执行：execution(* set*(..))\n- AccountService 接口的任意方法的执行：execution(* com.xyz.service.AccountService.*(..))\n- 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..))\n- 定义在service包和所有子包里的任意类的任意方法的执行：execution(* com.xyz.service..*.*(..))\n\n- 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：execution(*com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))\")\n- pointcutexp包里的任意类： within(com.test.spring.aop.pointcutexp.*)\n- pointcutexp包和所有子包里的任意类：within(com.test.spring.aop.pointcutexp..*)\n- 实现了Intf接口的所有类,如果Intf不是接口,限定Intf单个类：this(com.test.spring.aop.pointcutexp.Intf)\n- 当一个实现了接口的类被AOP的时候,用getBean方法必须cast为接口类型,不能为该类的类型\n- 带有@Transactional标注的所有类的任意方法： @within(org.springframework.transaction.annotation.Transactional) @target(org.springframework.transaction.annotation.Transactional)\n- 带有@Transactional标注的任意方法：\n  @annotation(org.springframework.transaction.annotation.Transactional)\n  @within和@target针对类的注解,@annotation是针对方法的注解\n- 参数带有@Transactional标注的方法：@args(org.springframework.transaction.annotation.Transactional)\n- 参数为String类型(运行是决定)的方法： args(String)\n\n## Spring aop测试\n\n### pom\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.5.RELEASE</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-aop</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n### aspect\n\n```java\n@Component\n@Aspect \npublic class DemoAspect {\n\n\n    //切入点1：匹配xxx类下的方法名以demo开头、参数类型为int的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo*(int))\")\n    public void matchCondition() {}\n\n    //切入点2：匹配xxx类下的方法名以demo开头、参数类型为long的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo1*(long))\")\n    public void matchCondition_() {}\n\n    //前置\n    @Before(\"matchCondition()\")\n    public void before() {\n        System.out.println(\"Before\");\n    }\n\n    //全局后置\n    @After(\"matchCondition()\")\n    public void after(){\n        System.out.println(\"after\");\n    }\n\n    //返回后置\n    @AfterReturning(\"matchCondition()\")\n    public void afterReturning(){\n        System.out.println(\"afterReturning\");\n    }\n\n    //抛出后置\n    @AfterThrowing(\"matchCondition()\")\n    public void afterThrowing(){\n        System.out.println(\"afterThrowing\");\n    }\n\n    @Around(\"matchCondition_()\")\n    public Object around(ProceedingJoinPoint joinPoint) {\n        Object result = null;\n        System.out.println(\"before\");\n        try{\n            result = joinPoint.proceed(joinPoint.getArgs());//获取参数\n            System.out.println(\"after\");\n        } catch (Throwable e) {\n            System.out.println(\"after exception\");\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"finally\");\n        }\n        return result;\n    }\n\n}\n```\n\n### service\n\n```java\n@Service\npublic class DemoService {\n\n    public void demo(int arg1){\n        System.out.println(arg1);\n    }\n\n    public void demo1(long arg1){\n        System.out.println(arg1);\n    }\n    \n}\n```\n\n\n\n### test\n\n```java\n@SpringBootTest\npublic class DemoServiceTest {\n    \n    @Autowired\n    DemoService demoService;\n\n    //测试单独四个\n    @Test\n    public void testDemo1(){\n        demoService.demo(1);\n    }\n    \n    //测试around\n    @Test\n    public void testDemo2(){\n        demoService.demo1(1L);\n    }\n}\n```\n\n## 参考\n\n[1].[Spring AOP——简单粗暴，小白教学](https://blog.csdn.net/qq_41981107/article/details/87920537)\n\n[2].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[3].[关于 Spring AOP (AspectJ) 你该知晓的一切](https://zhuanlan.zhihu.com/p/25522841)\n\n[4].[Spring AOP用法详解](https://www.cnblogs.com/liantdev/p/10125284.html)\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"Gitee图床+typora&notion+snipaste","url":"/2020/12/26/杂项/Gitee图床+typora&notion+snipaste/","content":"## 摘要\n* 软件的下载地址\n* 配置PicGo图床，把gitee作为图床\n* markdown软件typora，notion1简介\n* 截图软件snipaste快速配合PicGo\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 软件下载\n\n> [1].[图床软件PicGo](https://molunerfinn.com/PicGo/)\n>\n> [2].[typota](https://typora.io/)\n>\n> [3].[notion](https://www.notion.so/)\n>\n> [4].[snipaste](https://www.snipaste.com/)\n\n## 使用\n\n### typora,notion\n\ntypora和notion都是支持Markdown语法的文档编辑器，但是notion支持更多的功能，比如生成如下形式的文档\n\n![](https://gitee.com/BothSavage/PicGo/raw/master/image/20201226130027.png)\n\n### picgo\n\n所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 `Electron-vue` 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用\n\n> 推荐使用gitee，因为github访问不稳定\n\n- 直接搜索gitee在PicG的插件界面，安装picgo-plugin-gitee-uploader\n- 对应填好如下属性\n\n- - 其中repo为**用户名/仓库名**\n  - branch默认为master\n  - token的获取方法在下面\n  - path为子文件为目录\n\n- ![](https://gitee.com/BothSavage/PicGo/raw/master/image/1602233669972-05e582dc-5379-4b2b-ac8d-4ecb1789093c.png)\n\n### snipaste\n\n这是一款强大的截图工具，默认热键为F1，截图完成后点击右下角复制到剪切板，再使用图床的默认热键，快速完成图片上传\n\n![](https://gitee.com/BothSavage/PicGo/raw/master/image/20201226131235.png)\n\n## 参考\n\n[1].[Typora 完全使用详解](https://sspai.com/post/54912/)\n\n[2].[PicGo图床使用](https://www.yuque.com/u2063760/xbfae1/mipufs)\n\n\n\n\n\n","tags":["工具","git","图床"],"categories":["杂项"]},{"title":"Hexo结合Stun静态博客搭建从入门到入土","url":"/2020/12/19/杂项/Hexo结合Stun静态博客搭建从入门到入土 - 副本/","content":"## 摘要\n* 安装npm，安装hexo相关依赖，安装主题stun\n* 修改hexo配置，修改stun配置，部署到github，gitee实现静态访问\n* 给博客加上全局搜索，访问量统计\n* hexo博客编写模板\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 搭建环境\n\n### 创建仓库\n\n1.github\n\n> 仓库命名为：{$你的ID}.github.io\n\n2.gitee\n\n> 仓库命名为：{$你的ID}  \n\n***仓库名大小写一致，访问路径也是***\n\n### 环境安装\n\n1.安装npm\n\n> https://nodejs.org/en/download/\n\n2.安装cnpm\n\n```\nnpm install cnpm\n```\n\n3.安装博客搭建框架hexo\n\n```\ncnpm install -g hexo-cli\n```\n\n4.新建一个文件夹，并且之后所有操作都基于该文件夹\n\n```\nmkdir {$xxx}\ncd {$xxx}\n```\n\n5.安装依赖，下载主题\n\n```\ncnpm install --save hexo-deployer-git \ncnpm install --save hexo-render-pug\ncnpm install --save hexo-generator-search \ngit clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n```\n\n6.增加页面导航\n\n```\nhexo new page categories\nhexo new page tags\n```\n\n> 项目目录/source/categories/index.md  加上\n>\n> ```\n> type: categories\n> ```\n>\n> 项目目录/source/tags/index.md  加上\n>\n> ```\n> type: tags\n> ```\n\n### 修改配置文件\n\n1.修改部署文件夹下/_config.yml（挑选重要部分修改）\n\n```\n#展示设置\ntitle: {$自定义文字}\nlanguage: zh-CN \nurl: {$博客地址}\n\n#主题\ntheme: stun\n\n#git相关\ndeploy:\n  type: git\n  repo: \n  \tgithub: {$你的博客仓库}\n  \tgitee: {$你的博客仓库}\n  branch: master\n\n#搜索相关\nsearch:\n  path: search.json\n  field: post\n  content: true\n```\n\n2.修改部署文件夹下/themes/stun/_config.yml(挑选重要部分修改)\n\n```\n#取消导航栏注释（注意空格对齐）\nmenu:\n  categories: /categories/ || fas fa-layer-group\n  tags: /tags/ || fas fa-tags\n  \n#更改图标(最好使用链接地址，我这里使用的图床，图床使用见下一篇博客)\nfavicon:\n  small: https://gitee.com/BothSavage/PicGo/raw/master/image/favicon-16x16.png\n  medium: https://gitee.com/BothSavage/PicGo/raw/master/image/favicon-32x32.png\n\n#更改背景大图\nheader:\n  bg_image:\n    enable: true\n    url: https://gitee.com/BothSavage/PicGo/raw/master/image/背景.png\n\n#更改头像大图，并设为圆形\nauthor:\n  avatar:\n    url: https://gitee.com/BothSavage/PicGo/raw/master/image/头像.png\n    rounded: true\n    \n#打开访问统计\nbusuanzi:\n  enable: true\n  \n#打开搜索功能\nlocal_search:\n  enable: true\n\n```\n\n### 运行\n\n1.基础命令\n\n```\nhexo c  #清理一下\nhexo g  #生成\nhexo s  #部署到本地4000端口\nhexo d  #部署到远程Github仓库\n```\n\n2.推荐命令\n\n```\n#第一次尝试本地是否能访问\nhexo c  && hexo g && hexo s\n#以后每次添加文章\nhexo c  && hexo g && hexo d\n```\n\n### 博客文件存放地点\n\n> 项目目录/source/_posts\n\n## markdown文件规范\n\n1.文章元数据\n\n```\n#分别指定文章标题，时间，类别，标签\n---\ntitle: Hexo结合Stun静态博客搭建从入门到入土\ndate: 2020-12-19  20:40:11\ncategories:\n- 杂项\ntags:\n- 前端\n- 建站\n---\n```\n\n2.主页不显示文章全部\n\n```\n 上面是显示内容\n <!--more--> \n```\n\n## 其他高级功能\n\nstun主题支持\n\n* 评论系统\n* 站长工具\n* 数据公式\n* 网站特效\n* ................\n\n详情请查看\n\nhttps://theme-stun.github.io/docs/zh-CN/\n\n## 参考\n\n[1].[菜鸟教程：NodeJS安装配置](https://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n[2].[Stun主题指南](https://theme-stun.github.io/docs/zh-CN/)\n\n[3].[静态博客搭建](https://www.yuque.com/u2063760/xbfae1/gf45k1)\n\n[4].[_more截断文章_多标签添加](https://blog.csdn.net/Aoman_Hao/article/details/79291741)\n\n[5].[在gitee上部署静态网站（或者个人博客）](https://blog.csdn.net/zhangyu4863/article/details/80473412)\n\n","tags":["前端","建站"],"categories":["杂项"]},{"title":"设计模式(10)-装饰模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(10)-装饰模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(11)-外观模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(11)-外观模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(8)-适配器模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(12)-享元模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(13)-组合模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(13)-组合模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(7)-代理模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(7)-代理模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(8)-适配器模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(8)-适配器模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(9)-桥接模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(9)-桥接模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(15)-策略模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(15)-策略模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(16)-命令模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(16)-命令模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(17)-责任链模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(17)-责任链模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(18)-状态模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(18)-状态模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(19)-观察者模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(19)-观察者模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(20)-中介者模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(20)-中介者模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(21)-迭代器模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(21)-迭代器模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(14)-模板方法模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(14)-模板方法模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(22)-访问者模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(22)-访问者模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(23)-备忘录模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(23)-备忘录模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(24)-解释器模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(24)-解释器模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"Hello World","url":"/1920/06/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]