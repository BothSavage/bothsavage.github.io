[{"title":"万里长征0-面试题汇总","url":"/2022/01/01/面试/万里长征0-面试题汇总/","content":"\n## 待到秋来九月八，我花开后百花杀\n\n<!--more-->\n\n\n\n\n# 贝壳\n\n* LeetCode 199，二叉树右视图。\n* [Dubbo](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247489782&idx=1&sn=efbe773e62b12ad291d7801e3affc014&scene=21#wechat_redirect) 跟 [Spring Cloud](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247487072&idx=1&sn=3010908c4b668edef8fbd1f320343354&scene=21#wechat_redirect) 区别，自己从宏观到细节简单对比着说下。\n* 限流算法中的令牌跟漏斗区别。Zuul 作用。\n* 项目细节讲解，流程图，瓶颈在哪儿。\n* 开发人员写出死循环，发布上线后如何查出此问题来。\n* QPS，如何压测，性能测试，性能指标。\n* 性能优化经验，聊一聊。\n* 线程池说下，如果一堆线程任务有20%概率失败，如何保证100% 成功。\n* 职业抉择，算法工作为什么转到知识图谱工程了。\n* 目前应聘的岗位是纯 Cloud 开发，你的劣势。\n* 关于图数据库的不同种类了解及对比，比如Neo4j、DGraph、GanusGraph。\n\n# 跟谁学\n\n* LeetCode 662.二叉树最长直径。\n* [秒杀场景设计](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247492944&idx=1&sn=d70c2a10550f427fc7f9de70495661b9&scene=21#wechat_redirect)，逐步引导设计思路。\n* 项目的细节探讨及框架流程图，如果项目数据量、并发度扩大十倍咋办，哪儿是性能瓶颈。\n* 消息中间件，如何保证消息不丢失，如何实现消息消费顺序性。Kafka为什么那么快，Kafka重平衡问题。\n* 非toC岗位到toC岗位的心态切换，抗压能力。\n* SpringCloud那套东西的压力感。\n* [MySQL理解](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247488721&idx=1&sn=eead82d2b7a0fdf993beacc4dfd60313&scene=21#wechat_redirect)，事务隔离级别，MVCC，三个日志文件作用。\n* 现在做的东西的数据并发量跟业务复杂度探讨。\n* 自我讲解个满意项目，项目亮点。\n* 操作系统中的[阻塞、非阻塞、同步、异步、BIO、NIO、AIO](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247491968&idx=1&sn=aae7754ada52f2e0dba2ece2b1d70c8c&scene=21#wechat_redirect)细节。\n* 日常如何自我学习。\n* LeetCode 215 TOP K。\n* 项目介绍，面试官挺忙的，没咋问项目细节。\n* Redis跟MySQL[缓存一致性](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247493151&idx=1&sn=512aca5c0cc9dc75006a917317293ad1&scene=21#wechat_redirect)\n* 你对Dubbo底层理解。\n* 你对DDD的理解。\n\n# 搜狐\n\n* MapJoin 是什么？\n* Hive 数据倾斜 咋办？\n* cluster by order by reduce by distribute by区别。\n* Kafka 为何那么快。\n* MySQL B树 B+树区别。\n* UDF、Spark、Netty、BIO、NIO、AIO框架。\n* LeetCode 103. 二叉树的锯齿形层序遍历。\n* 项目介绍，框架流程图，自己负责的部分，数据治理的理解及实战场景。\n* MapReduce流程， Shuffle过程细节，数据倾斜如何避免。\n* hive语句书写，开窗函数的考察。\n* ZooKeeper的理解，分布式事务2PC、3PC、TCC、Paxos实现思路及优缺点。\n* 自己项目介绍，简单了解下职业规划等东西。\n* LeetCode 5. 最长回文子串。\n* 项目介绍，负责模块。\n* HBase架构图，LSM理解。\n* Spark在工作中的应用细节。\n* Scala语言的熟悉程度，Scala跟Java的区别关系。\n* 你所应聘的岗位主要职责。\n\n# 脉脉\n\n* MySQL 优化  查询 如何优化这些操作。\n* MySQL的 ACID理解，如何保证的，MySQL底层架构是啥。\n* Redis的几个基本数据类型，底层实现。\n* RabbitMQ 工作的几种不同模式，数据如何保证顺序性跟不丢失，如何避免数据重复消费。\n* Linux 常见指令(说点高级指令比如tmux，awk，别扯 ls、cd)。\n* MySQL为什么不建议用Text。\n* MySQL limit 10W,10 这样的优化，覆盖索引的使用。\n* Linux CPU满负荷如何排查。\n* 链表是否有环， 如何找到交点，计算出环的大小。\n* 一个字符串中的最长无重复子串。\n* 一个帖子来回回复如何存储，如何设计。\n* 一个数组包含10W个数据，数据范围都在0~100，请求出两数相加和为100的情况一共多少种。\n* 分布式锁实现方案。\n* Redis为什么那么快，Redis底层实现。\n* RabbitMQ 中的TTL。\n* Redis中常见集群部署情况，出现性能问题如何排查。\n\n# 小米\n\n* 两个字符串求最长公共子序列，最长子串。输出字符串结果的那种。\n* Hbase的理解，LSM演变过程。\n* 项目介绍，数据治理方面的理解。\n* 简单SQL语句考察，MySQL各种索引跟如何优化。\n* Kafka 重平衡，Kafka架构图的理解，读写流程。\n* LeetCode TOP K 。\n* 项目介绍，瓶颈延伸，自我复盘。\n* 你对Spring的理解，循环依赖。\n* 不停机修改MySQL一个字段，如何对MySQL进行服务器扩容。\n* RabbitMQ 如何保证消息不丢失，如何保证消息顺序性。\n* 1G内存，1T文件，想找到出现次数第二大的字符串。\n* 进程间通信几种方式，每种方式的优劣性。\n* 项目介绍。\n* 过往算法工作的项目讲解、西瓜书、机器学习实战的学习心得。\n* 地球上所有湖泊跟大海的体积如何求？大学数学建模大赛相关信息。\n* 内核态跟用户态的理解，操作系统的几个核心点及调度算法。\n* 实现字符串语句翻转比如 I LOVE C++ 变为 C++ LOVE I。\n* 岗位职责要求。\n\n# 百度\n\n* TCP 阻塞如何解决。\n* Java HashMap 7 跟 8 的流程设计理念，为什么7中会出现环。\n* Java 线程池参数。\n* Synchronized 的理解。\n* ReentrentLock 优势跟用法。\n* 公平锁跟 非公平锁 的理解。如何抉择用哪个。\n* Redis中的事务。\n* Redis中的zset底层。\n* Redis IO多路复用机制。\n* Kafka 为什么那么快，消费者组的理解，Kafka的重平衡。\n* MySQL隔离级别，MVCC理解。\n* 最近最有挑战性的项目。\n* Spring AOP 的理解，实现原理，String字符串拼接成目标类然后通过反射出所需class。\n* LeetCode 572，判断 一个二叉树在另外一个二叉树中。\n* 告知不太匹配，但面试时感觉聊的挺融洽的，感觉被刷KPI了。\n* 二叉树左右节点互换，自己写出求解过程及测试用例。\n* 区间合并，自己写出求解过程及测试用例。\n* 多个链表进行合并，自己写出求解过程及测试用例。\n* HBase底层架构组成，LSM理解。\n* Clickhouse跟Spark的理解。\n* 面试官全程没开视频，错误的以为我只有一年工作经验。\n* 告知不太匹配，再一次感觉被刷KPI ，爱消失了。\n\n# 美团\n\n* 图数据的引擎了解么，简单聊一聊，Dgraph，JanusGraph。\n* 聊下项目，项目的技术难点。\n* 你对[高并发](https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&mid=2247493322&idx=2&sn=8b8dd6d02da20f2f184827cd61fb86c8&scene=21#wechat_redirect)的理解。\n* 二叉树转换为双向链表，剑指offer 36 。\n* JVM 垃圾回收器 聊一聊，CMS 优缺点，三色标记法过程细节，G1的优缺点跟实现过程 。\n* HashMap 跟 ConcurrentHashMap 区别跟细节实现，线程不安全在哪里？\n* Hive底层执行流程了解么。\n* 燕京大学跟你们学校啥关系。\n* 进程A操作变量x，然后报变量地址写入磁盘，进程B是否可以操作。\n* 类似360开机打败全国多少那种设计，正态分布。定期更新模型核心参数。\n* TCP 知识点考察。\n* 前端请求从发出到最终得到响应，整个数据的流转过程。\n* 设计一个数据结构支持O(1)的insert、remove、random。\n* 由于上一次的二面面试官认为岗位不太匹配，所以被内推到了另外一个部门面试，估计前面的2轮面评还不错，所以这次竟然没有3面。\n* 个人介绍，项目架构图，自我感觉项目难点，现在再让你重新做这个项目你会有什么修改跟调整。\n* 项目数据细节问题。\n* RabbitMQ 跟 Kafka 对比下，说下对MQ的理解。\n* mmap java里怎么实现的，ZeroCopy的演变历程。\n* 在线服务如何保证稳定性，感觉又关联到了高并发的理解上了。\n* 常用的负载均衡算法，自己选择个负载均衡算法来实现并进行自测。\n* Dubbo 跟 Spring Cloud 开发的区别跟理解。\n* 常用限流方法，自己咋实现。\n* 分布式链路追踪的实现跟理解。\n* 个人介绍，你对数据治理的理解。\n* 平常如何提升自己，你对JUC的理解。\n* 对以前做的AI项目简单讲解下，你负责哪块。\n* 你目前手头offer，你的面试计划跟安排是啥。\n* 对于数据治理的理解，Java开发 + 大数据开发 + BI 报表 + 推荐搜索，整个数据流转的过程的认知。\n\n# 字节\n\n* 项目介绍，你负责的模块，技术难点。\n* Kafka为什么那么快，Kafka重平衡咋处理的\n* HTTP的发展史理解优缺点，公钥、私钥理解跟加密过程。\n* 操作系统内存、进程、IO、文件管理的理解，自己大致说下理解。\n* Leetcode 8.atoi ，注意边界问题。\n* 项目介绍，求职岗位的工作内容描述。\n* Hive执行底层流程。\n* Hadoop的发展史，自己说下HDFS、MapReduce、Yarn等组件跟数据流转过程。\n* Kafka生产者消费者速度不平衡咋办，Kafka重平衡。\n* Redis跟MySQL那套八股文的知识点。\n* LeetCode 236. 二叉树的最近公共祖先。\n* ZooKeeper 的理解。\n* 聊项目，自我评价下项目的技术短板，数据重复消费如何解决。\n* RabbitMQ 跟 Kafka 聊一聊 宏观 自己说那种。\n* 线程池如何实现参数的动态修改。\n* Hive执行的底层原理。\n* 字符串消消乐。\n\n# 快手\n\n* 链表是否存在环，如果存在咋找到入口，如何获得环长度，为什么fast是2步，3 4 5 步行不行？多思考下细节问题。\n* 线程咋打断，interrupt 用法。\n* LeetCode 124，给定一个非空二叉树，返回最大路径和。\n* JUC 高频八股文考点。\n* syn跟Lock对比，如何进行选择性使用呢。\n* BitMap 统计那些数据出现过，那些没出现过。\n* 还有好几个是场景设计思考的题，当时能说个12，然后面试官会引导你，看你是否能说出个3来。\n* 业务数据处理时数据治理问题，如果规则引擎经常增删如何实现高效的对外服务。\n* 大数据从数据收集到对外提供服务的思维跟理念，数据从MySQL、Redis、MongoDB等各种平台获取到后，如何提供对外服务。如何提供高质量的服务呢\n* 数据提供服务需要考虑的点，OLAP、OLTP、高性能、高可用、高扩展。\n* A服务器a，B服务器文件b，如何判断 ab文件是否一致，尽可能的避免来回传输。\n* MySQL用户数据，如何保证高可用，你对高并发的理解是啥。\n* 数据治理方面的思想idea。\n* 无损降级听过吗。\n* 布隆过滤器的思想，多个布隆过滤器的思想？\n* 服务治理的思考。\n* 10块糖，每次最多3个 如何保证必须赢， n块糖呢？如何保证赢。\n* 你负责的是什么部分，你感觉最大挑战是啥，选个感觉最好的项目说一说。\n* 你对大数据架构体系理解。fast counter 如何实现  类似 变量 i++那种(没及时沟通，充分理解题意)。最后知道考察的是LongAdder 跟 ThreadLocal。\n* hive 实现底层 ，开窗函数的考察。\n* Redis中的常见高频考点。\n* syn 对象头咋回事，锁升级过程。\n* 调度框架 爬取10万个URL，10万个URL 属于不同的节点， 每个节点有不同的访问频率跟总次数限制，如何实现。\n* Kafka架构体系说下，自己的理解。Leader自己理解下。\n* 日常学习方式跟思维，如何度过新工作的切换期。\n\n# 科大讯飞\n\n* 公司数据量有多少\n* 数据量这么多怎么优化（如何分库分表）\n* 虚拟机内存结构\n* start和run的区别\n* 双亲委派模型\n* redis的数据类型\n* redis一般存什么数据\n* 怎么虚拟机调优\n* 创建线程的方式有几种\n* 介绍下线程池\n\n# 大华\n\n* sql优化\n* 虚拟机参数，虚拟机内存模型\n* redis的数据类型\n* redis持久化方式的区别\n* synch锁膨胀的过程\n\n# 海康威视\n\n* 自我介绍 + 项目介绍\n* hashmap是否安全\n* concurrentHashmap\n* 线程run和start区别\n* 怎么优化sql\n* 介绍forkJoinPool，为什么使用这个\n* 虚拟机的内存结构\n* 双亲委派模型\n\n# 美团\n\n* 如果因为一些原因，线上Redis挂了，然后所有请求打到数据库层导致数据库也挂了，这时该怎么进行恢复？\n\n*  Spring里面的bean id是否允许重复？如果允许重复的话重复了怎么办？如果不允许重复是怎么处理的\n\n*  G1对宿主机有什么要求？\n\n*  堆设置有什么注意事项？\n\n*  Spring和Mybatis是怎么结合的？\n\n*  mysql explain有哪些项？\n\n*  dubbo协议\n\n*  单链表找循环节点\n\n# 小米\n\n*  手写Dubbo的加权随机算法\n\n* Spring获取代理对象解决事务失效的问题\n\n*  顺序读取一亿个整数，找出前100万大的数字，内存限定大小为10M，后内存限定大小为5M。\n\n# 滴滴\n\n*  一个升序数组，随机选择一个旋转节点。右边的有序段放到左边，依然保持有序；左边的有序段放到右边，依然保持有序。然后从这个数组中查找某个数。\n\n*  stream和foreach区别\n\n*  zookeeper和nacos区别？nacos符合CP还是AP？\n\n# 滴滴\n\n* 自我介绍+介绍项目\n* 项目中难点及解决办法\n* Java线程的状态及转换\n* Java创建线程的方式\n* 创建线程池的方式有哪些\n* JUC包下的类，能说多少说多少\n* ReentranLock与sychronized的区别\n* volitile的内存语义，底层如何实现\n* 解释一下happens-before，有哪些规则\n* CurrentHashMap源码\n* MySQL的索引及区别\n* 算法题：顺时针打印矩阵\n* 介绍项目，项目中的难点(15min)\n* MySQL是如何优化的，数据量有多少\n* 倒排索引与正排索引的区别\n* ElasticSearch的原理(倒排索引+TF/IDF)\n* Zookeeper用过吗，介绍一下\n* Zookeeper一般用在什么场景\n* 除了ZAB协议，在介绍几个分布式一致性协议(Paxos、Raft)\n* 线程池的几种拒绝策略及其应用场景\n* 大数据框架有哪些\n* LSM-tree应用在那些场景、优缺点\n* 写SQL：查询每个班级成绩排名前五的学生及成绩\n* 你对滴滴有什么了解，知道我们的技术栈吗\n* Java集合类常用哪些，ArrayList与LinkedList区别；HashMap底层实现，为什么扩容是2的幂次；如果想要线程安全该怎么用\n* JUC包下对哪些类了解，synchronized和JDK提供的锁区别；CAS原理，ABA问题；锁升级过程讲一下；volatile讲一下，为什么不能保证原子性\n* JVM内存模型，新生代有哪些区，作用是什么；如何判断对象是否可以被回收（1引用计数2可达性分析）\n* JVM常用垃圾回收算法，讲一下CMS原理\n* Redis常用数据结构；有序集合底层实现；查找排名在底层如何实现；如何用Redis实现分布式锁，可能遇到的问题和解决办法\n* 手撕一个二分查找\n* 自我介绍，项目提问\n* 聊计网，TCP3次握手过程，第三次是否可以携带数据，如何避免SYN攻击（syncookies）；TCP四次挥手说一下，为什么要等待2MSL，第二次和第三次挥手是否可以合并（可以）。\n* 操作系统，进程、线程和协程的区别；如果创建很多个线程会有什么问题；进程间通信方式有哪些\n* MySQL索引如何实现，为什么用B+树不用B树二叉树；聚簇索引和非聚簇索引的区别；平时索引优化如何做，最左匹配原则；\n* 你的优点，你的缺点（面试官说我们缺点一样）\n* 你最近看的技术书籍，我提到《Java并发编程的艺术》看了三遍，面试官让我详细每一章讲了什么\n* 你对互联网行业怎么看\n* 如果你的绩效被打了C你会怎么办 （这个是一个很大的坑~）\n\n# 小砖\n\n* 面向对象中的组合和聚合区别\n* 数据库范式，为啥要有范式\n\n# 佰钧成\n\n* mysql隔离级别\n* springaop属于什么设计模式\n* 设计模式了解哪些\n* springmvc流程 \n* 多线程链接池的原理\n* aop的应用\n* spring如何赋值给属性类\n* springaop设计模式\n* sql优化\n* sprng、boot用过没有\n* wait和sleep区别，如果sleep还未到时间我要唤醒如何做?\n* sql优化?具体怎么优化?\n# 三年\n\n* 为什么用es，与solr对比\n* es怎么用的，怎么保持一致性\n* 为什么用springcloud，与dubbo对比\n* mysql 优化经验 索引 \n* mysql用什么隔离级别，考虑过用RC吗\n* mq对比，要求可靠性，高吞吐用哪个mq\n* redis数据类型 用那种多一点 分布式锁\n* redis扛不住怎么办，不允许限流降级\n* 项目中用的哪个回收器，G1回收流程，G1适合的场景\n* 多线程方面用过什么，线程池，哪几种，怎么用的\n* spring aop原理\n* 数据库查询优化，索引\n* 数据库锁表怎么解决\n* java syncronized 原理\n* volatile\n* spring ioc & aop\n* spring中设计模式\n* 单例模式 duble check\n* jvm 组成\n* 垃圾收集器\n* String StringBuilder StringBuffer\n* 创建对象多怎么调整JVM参数\n* mybatis 原理\n* rabbitmq/kafka 怎么保证可靠消息\n* 什么情况内存泄漏\n* 静态方法能覆盖吗\n* gap lock\n* https原理\n* eureka原理，与zookeeper\n* 分布式事务\n* springboot内存占用优化？\n* 斐波那契数列\n# 哈啰\n\n* 项目介绍\n  * 这一环节，主要介绍自己的项目，面试官后续就会根据这个项目中的技术点针对提问，所以一定要对自己的项目非常熟悉。**项目介绍的时候，不要一上来就说一些复杂的项目方案。**因为在不了解的项目的背景和一些问题的情况下，大家理解的上下文是不一样的，这样就会造成双方之间理解的误差。所以项目介绍的时候，**首先介绍一下项目的背景**。在面试官的了解之后，那我们可以开始介绍项目的一些整体架构等等。介绍完成之后，面试官就会根据你说到技术点，然后开始提问。下面是这次面试官提出的一些问题。\n\n* 微服务如何拆分\n\n* 为什么从单体服务过度到微服务\n\n* 首先介绍一下单体服务优点：\n  * 架构简单，系统复杂度低，部署简单。简单而言，当业务场景简单，开发人数少，功能并不复杂的时候，就比较适合单体架构。随着开发人数变多，功能变得复杂，单体服务就会出现痛点：服务耦合，互相影响。团队开发变得复杂，版本管理变得复杂，容易出现打架情况\n\n* 微服务监控怎么做的？\n  * 基于自己公司的监控体系回答，如果实在没有什么监控，可以说说自己了解的监控体系。\n\n* 如何评估服务应用需要扩容？\n  * 这个可以参考沈剑老师的[互联网架构，如何进行容量设计？](https://www.w3cschool.cn/architectroad/architectroad-capacity-design.html)\n  * 评估总访问量，评估平均访问量，评估峰值访问量，压测，单机极限 qps，适当的冗余服务\n\n* 如何及时发现系统异常的情况？\n  * 系统监控，对于异常日志，使用 ELK 进行关键日志报警。另外针对关键接口进行响应延时，吞吐量等监控，一旦出现下降，进行报警。\n* 微服务通讯方案如何选择\n  * 现在主流就是以下两大方案：Dubbo RPC Spring Cloud分别介绍一下，Dubbo 与 Spring Cloud，介绍优缺点，然后说一下你的选择方案，你为什么这么选。\n\n* 分布式中间件如何选型？\n  * 思路同上题，可以举个例子，然后列出可以用中间件，比较中间件优缺点，横向对比分析，最后基于业务场景选择。\n* 微服务分布式事务如何解决\n  * 如果没有实际用过，可以说下分布式事务一些解决方案：2PC，TCC，如果有实际使用经验，那就说下自己项目中如何使用。\n\n* MQ 系列问题\n  * 下面这些常规问题，网上一般都能找到答案，这里就不详细解释了。\n  * mq 消费失败，如何重发\n  * 重复消费问题\n  * 消息丢失问题\n\n* Dubbo 系列问题\n  * 负载均衡在消费者实现还是服务提供者实现？\n  *  负载均衡如何实现\n  * 服务动态发现如何实现？\n\n* 看你介绍，会研究源码，看过什么源码\n  * 又回到主观题了，介绍一下自己看过的源码，可以从一例子介绍一下源码。\n\n* 现在换工作，主要注重什么\n  * 这个问题不用说了吧~\n\n* **最后，常规问题，你有什么要问的**\n  * 根据面的轮数不一样，进行相应的回答。比如一面的话，那就不要问薪资待遇这些问题，问了也没啥用。我通常问他，你们负责业务到底是什么，具体架构是什么等等。\n\n## 美团\n\n* 自我介绍\n* 编程相关的书籍还看了哪些\n* 有没有写一些博客和开源项目\n* 学习安卓(如果你是别的，那就换成学习别的)的时间\n* （Java）String、StringBuffer 和 StringBuilder 的区别\n* （Java）String 的内部实现 \n* （Java）String 对象主要存储在哪块区域（常量池）\n* （Java）重载和重写的区别\n* 口诀：重写（两同、两小、一大），重载（方法名一致，形参列表不同）\n* （Java）HashMap 和 HashSet 的区别\n* 思路：可以从Map和Set的区别、HashMap和HashSet的方法与底层原理入手分析。\n* （Java）写一下 HashSet 的实现\n* 思路：可以用HashMap的key作为HashSet的元素（不可重复性），同时令HashMap的value为同一个Object\n* 建议：像这种涉及到源码的题目，如果面试时候不记得源码，可以试着先找规律，一步步推理，面试官会给思考时间的。同时一定要记得多跟面试官交流，问清楚需求。\n* （JVM）运行时数据区 \n* （JVM）创建对象的过程\n* （JVM）判断一个对象是否被回收\n* （JVM）新生代和老年代用的垃圾回收策略\n* （安卓）activity、window 和 view 之间的关系\n* （操作系统）LRU 的实现\n* LRU缓存机制（力扣146题）\n* （计网）HTTP的缓存机制\n\n* 查找单向链表的中间结点，lc第876题\n* 链表的倒数第 k 个节点，剑指第22题\n\n* 一些关于项目的问题，建议项目问题回答遵循 STAR 法则【STAR法则是情境(situation)、目标（target）、行动(action)、结果(result)】。\n* 开发项目时候遇到哪些比较困难的问题，怎么解决的\n* 个人职业生涯规划是什么样的\n* 你希望在什么样的团队里面\n\n* （Java）HashMap、HashTable 和 ConcurrentHashMap 的区别\n* （Java）强引用、弱引用、软引用和虚引用的区别（我还加上了一个终结器引\n* （操作系统）线程的生命周期\n* （操作系统）sleep和wait的区别\n* （操作系统）死锁产生的原因\n\n* 最大子序和\n* lc第53题\n\n* 一个装了 10L 水的桶，一个 7L 的空桶，一个 3L 的空桶，怎样变成 2 个 5L\n\n* 除了 Java 以外，还用了什么语言（回答了 c++ 和 python）\n* 职业生涯规划\n\n* （语言类）c++ 和 java 在内存管理方面的区别\n* （语言类）c++ 有垃圾回收么\n* （JVM）对 gc（垃圾回收）的理解\n* （JVM）你觉得可达性分析用什么数据结构比较好（垃圾回收的延伸知识）\n* （JVM）管理内存的策略和机制有哪些\n* （JVM）垃圾回收算法\n* （语言类）内存泄露的场景\n* （语言类）c++ 中的对象类，对象内部的类是如何存储的，内部元素存储在哪些空间里面\n* （语言类）调用函数的实现机制\n* （计网）网络传输都做了哪些事\n* 思路：参考《浏览器中输入域名（url）后发生了什么》问题进行解答\n* （计网）如何保障网络传输的数据安全\n* （计网）AES 的加于RSA么\n* （计网）RSA 的实现原理\n* （计网）MD5 加密以后能解密么\n* （计网）网络传输中，你只把数据加密了，就能保证网络的安全么？有没有其他的隐患\n* （计网）有没有了解过如何规避 DNS 劫持\n* （计网）洪泛攻击的规避方法\n* （编程习惯）如何把代码设计的更好，更健壮\n* （编程习惯）常用的设计原则和设计模式\n\n* 滑动窗口的最大值，lc 239题\n* 顺时针打印矩阵，lc剑指29\n* 最小路径和，力扣64题\n\n* 前面的面试结束以后，对美团的基本情况有一定了解了么\n* 意向城市是上海的原因（简历和最后的业务不在同城而引发的问题）\n* 实习经历盘问，主要针对简历上的\n* 实习以后的收获\n* 选择岗位的偏向\n* 觉得自己经历过最难的项目是哪个3\n* 你还有其他 offer 么\n* 你手上这些 offer，你会怎么选\n* 反问环节：进去以后的部门和岗位，需要自己做选择么\n* 反问环节：如果有意向书的话，大概什么时候发放\n## 网易\n\n* final 关键字的作用，final 在多线程并发条件下的作用\n* 线程安全\n* Map 接口的实现有哪几种，实现的特性是什么\n* LinkedHashMap 的实现机制\n* synchronized 作用于不同方法和代码块的区别\n* 哪些方法可以创建线程池\n* DNS 域名解析过程\n* DNS 劫持\n\n* （计网）DNS 解析过程\n* （计网）DNS 协议的可靠性的设计\n* （计网）DNS 协议改进方式\n* （计网）TCP 的拥塞控制机制\n* （计网）HTTP 和 HTTPS 的区别\n* （计网）HTTPS 怎么保证安全性的，具体的流程是什么样的\n* （计网）对称加密和非对称加密的区别\n* （计网）HTTP 的版本差异\n* （操作系统）进程和线程的区别\n* （操作系统）个应用里面有多个进程么？回答 “可以” 了以后，继续问：在什么情况下需要一个应用里面有多个进程\n* （操作系统）在 Linux 系统下，有哪些进程调度的方式\n* （操作系统）跨进程通信的方式\n* （操作系统）信号量怎么理解\n* （操作系统）操作系统层面，怎么实现异常中断\n  设计一个小框架，实现加载一个图片库，实现的功能是：如果在内存中有图片，就先从内存中取；如果没有话，先查询磁盘，如果磁盘有的话就从磁盘中取；如果磁盘没有的话，再查询硬盘，如果硬盘中有的话，就从硬盘中取；如果都没有的话，就从远程网络中取。如果图片较大的话，要做一些限制。如何去设计和考虑，要着重关注下内存的缓存和控制。\n\n  * 本人的答题路线一直没有 get 到这个要点，其8实这道题，面试官的重点是内存的管控（他后面明确了问题：内存不够的时候该如何处理，什么时候把图片淘汰掉），要从 LRU 缓存上面开始说。回答 LRU 时候，还会问一些 LRU 底层使用的数据结构是如何设计的。\n\n* LRU 缓存机制（力扣 146 题）\n\n* 2 - 3min 的自我介绍，尽可能详细一些\n* 你为什么不选择产品经理，是觉得这个工作没有价值么\n* 你对自己的职业规划\n* 你有哪些 offer\n* 你对工作有什么要求\n* 你更关注哪些方面\n* 简单评价下自己，优势和不足\n* 求学期间，坚持最久的事情，除了兴趣爱好以外\n* 你遇到过最难的事情是什么\n* 你觉得你做的这些东西，最有价值的是什么\n* 最有成就感的事情\n* 兴趣爱好\n* 爱豆是谁\n* 云音乐等级多少\n* 反问：大概多久会有消息（HR 说那周六发意向书，结果一直拖到了周三）\n* 反问：薪酬大概多少（HR 说根据市场来定，看看大部分公司开价多少，实际上网易云是比较早开奖的一批，要尽快签约）\n## 字节\n\n* （基本问题）自我介绍和项目介绍\n* （计网）http和https的区别\n* （计网）浏览器中输入域名（url）后发生了什么\n* （操作系统）进程和线程的定义\n* （操作系统）进程通信方式\n* （java）四种类型强制转换\n* （java）数组和链表的区别\n* （java）深拷贝和浅拷贝\n* （jvm）如何判断堆中哪些对象需要被回收\n* （jvm）gc回收\n* （jvm）新生代和老年代都用什么算法\n* （算法）计算某个字符串的所有排列组合，并且按字符串逆字典序排序的方式输出。\n\n* （基本问题）自我介绍和项目介绍\n* （基本问题）学习路线\n* （海量数据问题）从海量数据中找出最大的前K个数\n* （jvm）jvm中，直接内存是什么\n* （java）final，finalize， finally有什么区别\n* （java）HashSet类如何实现添加元素保证不重复的\n* （算法）最长递增子数组的具体数组\n## 腾讯\n\n* （基本问题）自我介绍\n* （基本问题）安卓相关的项目，你做过哪个你觉得印象比较深的\n* （操作系统）进程和线程的区别\n* （操作系统）进程通信的方式\n* （操作系统）多线程的实现方式\n* （操作系统）线程安全怎么保证\n* （操作系统）volatile与synchronized的区别\n* （操作系统）用户态和核心态的区别\n* （计网）http和https的区别\n* （计网）http不同版本的区别\n* （算法题）可以使用jdk里面所有的类，随机创建一个链表，链表里面要含有100个随机的既有正数也有负数的节点。不可以自己创建链表类。\n* （算法题）移除上述链表中的负数\n* （算法题）用两个线程移除上述链表中的负数\n* （算法题）异或交换两个值，不可以用临时变量\n* （算法题）异或找出重复的元素：1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次，类似于力扣上的剑指 Offer 03. 数组中重复的数字\n* （场景题）十年前怎么防止http的明文信息被窃取。如果黑客窃取了你加密后的东西进行传输，你该怎么办\n* （计网）有哪些常见的加密算法\n* （计网）网络不安全的原因有哪些\n* （计网）洪泛攻击是什么\n## 腾讯\n\n* （算法题）最小公倍数，复杂度多少\n* （java）static的静态方法能不能被继承\n* （java）final修饰不同类，方法，基本数据类型的区别，修饰string类以后会怎么样\n* （数据库）事务是什么\n* （java）wait和sleep的区别\n* （java）面向对象的思想\n* （语言类）java和c++的区别\n* （操作系统）进程和线程的区别\n* （计网）tcp和udp的区别\n* （计网）udp适用场景\n* （基本问题）意向城市在哪里\n\n## 顺丰\n\n* （基本问题）自我介绍\n* （计网）http和https的区别\n* （计网）Http request的几种类型\n* （计网）GET 和 POST 的区别\n* （计网）TCP和UDP，区别\n* （操作系统）线程安全怎么保证\n* （操作系统）死锁产生的必要条件\n* （操作系统）线程的生命周期\n* （java）重载和重写的区别\n* （java）数组和链表的区别\n* （反问）工作所在地\n* （基本问题）自我介绍\n* （基本问题）为什么选择这个岗位\n* （java）HashMap原理\n* （java）哈希碰撞是什么\n* （java）HashMap为什么线程不安全\n* （java）用什么与HashMap有关的数据结构可以实现线程安全\n* （操作系统）用户态和核心态的区别\n* （计网）tcp拥塞控制算法\n* （反问）这个岗位需要做哪些内容\n* 自我介绍\n* 职业规划\n* 优缺点\n* 说一下印象比较深刻的项目\n* 最希望和什么样的上级共事\n* 期望的薪资是多少\n* 可以接受加班么\n* 你对我们这个岗位有什么想问的\n## 快手\n\n* （基本问题）自我介绍\n* （基本问题）项目分工和具体内容\n* （基本问题）是否有音视频方面的知识\n* （java）ArrayList和LinkedList区别\n* （java）List如何删除元素\n* （java）了解HashMap么\n* （java）HashMap为什么要用数组加链表的方式，这么做有什么优点\n* （java）哈希冲突的定义和解决方法\n* （操作系统）死锁产生的原因和解决办法\n* （java）内存泄露的原因，并举几个例子\n* （操作系统）volatile的作用及其应用场景\n* （算法）写一个快排\n* （反问）这个岗位做什么内容的，工作地点在哪里\n* （基本问题）自我介绍\n* （面试官叙述）本岗位是什么样的，需要什么样的人\n* （基本问题）你可以适应这个岗位的内容么\n* （基本问题）sdk的封装了解么\n* （操作系统）进程和线程的区别\n* （操作系统）进程调度算法\n* （操作系统）操作系统分配的进程空间是怎样的？线程能共享哪些\n* （操作系统）如何保证线程安全\n* （操作系统）线程池的创建方法\n* （java）static、final、static final的区别\n* （java）反射的定义和作用\n* （算法）剑指 Offer 24. 反链表\n* （反问）面试存在哪些问题\n* （基本问题）自我介绍\n* （操作系统）多线程里的关键字有哪些\n* （操作系统）volatile与synchronized的区别和使用场景\n* （操作系统）除了volatile的原子性和可见性以外，还了a解一些更底层的原理么，比如怎么保证原子性和可见性的\n* （操作系统）信号量如何交替进行的\n* （java）有哪些引用类型\n* （java）在垃圾回收时，无论内存是否充足，都会回收弱引用对象吗，WeakReference在消息机制中的怎么用的\n* （计网）TCP的三次握手\n* （计网）https加密的具体方式\n* （计网）https加密协商出来的密钥的类型是什么\n* （计网）SSL流程\n* （java）equals和==的区别\n* （java）讲一下hashCode方法\n* （算法）21. 合并两个有序链表\n## 百度\n\n* （基本情况）自我介绍\n* （基本情况）实践经验\n* （设计模式）了解单例模式么\n* （设计模式）单例模式的应用场景\n* （设计模式）说一下如何用你熟悉的编程语言构造一个单例模式，其他地方又是如何去调用的，说一下基本语法。\n* （数据结构）有了解过二叉树这种结构么\n* （算法1）104. 二叉树的最大深度：电话面试时候需要口述思路，不需要写代码。\n* 关于二叉树的学习方式推荐一下2021秋招算法总结4-二叉树篇，里面包括了一些面试常涉及到的二叉树的题目，感兴趣的同学可以按类别进行刷题。刷题时候不能只会写代码，还要注重思路的阐述，学有余力的同学可以试试不同的解法。\n* （算法2）面试题 08.08. 有重复字符串的排列组合：同时需要简述思路，并且要了解递归的过程，特别是剪枝的过程要说清楚。\n* 关于排列组合的题目，推荐一下2021秋招算法总结1-DFS篇，里面按类包含了大量可以用，但不限于用DFS求解的题目，方便大家对此类问题树立一个基本的解题思路。\n* （实践问题）常见的APP中有这么一个功能：每一个可以上下滑动，其次左右滚动时候可以在多个页面之间进行切换，如果让你写这个app，你会用哪些控件去实现。\n* （实践问题）你说用ReycclerView是放在上下滑动时还是左右滑动时\n* （实践问题）单个分栏中如何实现上下页的切换。\n* （反问）这个工作岗位是什么，需要学习哪些方面的内容\n* （基本情况）自我介绍\n* （基本情况）选择工作的考虑因素\n* （基本情况）可以接受ios开发的岗位么\n* （算法）再阐述下全排列的思路（一面算法2）\n* （基本情况）项目分工\n* （基本情况）学习路线\n* （基本情况）优缺点\n* （基本情况）是否可以提前实习\n* （基本情况）职业规划大赛\n* （反问）面试的流程是什么样的：两轮技术面，没有hr面\n8\n\n## 滴滴\n\n* （算法）剑指 Offer 24. 反转链表\n* （算法）剑指 Offer 25. 合并两个排序的链表\n* 关于链表的学习，推荐2021秋招算法总结3-链表篇，其中包含各个常考的链表的题目和一些面试者需要掌握的素质与提升的方法。除了滴滴之外，基4本上会考算法题的大厂都经常考链表相关的题目。在面试过程中，面试者需要先问清楚面试官需不需要你把链表的定义也写出来，还有就是需不需要运行出来。每个面试官考察的素质都是不一样的，事先准备的越充分，面试时候越游刃有余。\n* （基本情况）自我介绍\n* （基本情况）安卓学习路线\n* （计网）http和https的区别\n* （计网）TCP与UDP区别\n* （计网）TCP流量控制\n* （计网）Cookie与Session的作用与原理\n* （操作系统）进程和线程的区别\n* （操作系统）进程间通信方式\n* （操作系统）多线程里的关键字\n* （操作系统）synchronized应用场景\n* （java）wait() 和 sleep() 的区别\n* （jvm）Java内存回收机制\n* （jvm）垃圾收集器有哪些\n\n* （算法）88. 合并两个有序数组\n* （算法）56. 合并区间\n* （基本情况）自我介绍\n* （基本情况）选择这个岗位的原因\n* （基本情况）项目盘点\n* （面试官科普）本部门需要什么样的人：滴滴更喜欢有大型项目经历的人\n* （面试官科普）这个岗位需要的技能：有独立开发app的能力，可以快速上手布置的任务，给一个已经有的项目会懂得如何debug。\n* （反问）胜任这个岗位需要哪些技能，如何去学习：去实习\n* （反问）大公司需要掌握什么样的debug的方法：跟项目有关，实习时候会有人带\n* （反问）是否需要提前实习：面试官建议提前实习\n\n# 华为\n\n* 项目介绍\n* 笔试原题讲思路\n* 共享屏幕IDEA写 leetcode\n* 深拷贝和浅拷贝的区别；\n* 面向对象三要素；\n* 子类父类中静态代码、静态块以及构造器的加载顺序；\n* 静态方法能不能访问普通变量，原因？\n* 项目介绍（存储相关）\n* 共享屏幕IDEA写题；\n* Java 中实现线程的几种方式？（Thread，Runnable，Callable）区别在哪？\n* 上问拓展到了 Thread 是继承类，另外两种是实现接口。Java是单继承的，所以又问了Java 中接口和类的区别；\n* 文件系统中硬链接和软链接的区别；\n* 文件修改后，软硬连接对应的数据会变化吗？\n* 机械硬盘和固态硬盘性能差异原因；\n* 问是否会C++？函数传参时引用和指针的区别；\n* Java 中的方法是值传递还是引用传递；\n# 八年小红书大数据\n\n* 1.自我介绍\n* 2.介绍项目，架构，上下游，出现的问题，故障，怎么解决\n* 3.IO密级型的系统怎么设置堆内存大小？垃圾回收器怎么选择？\n* 4.多线程，数字处理到10位处理，然后循环处理，怎么做？\n* 5.mysql a b 字段索引，查询a=x,b=x会用到什么索引？如果想同时用到a b索引怎么做？\n* 6.oom怎么排查？\n* 7.大数据flink，流式计算\n* 8.之前带团队吗？怎么管理？\n# Soul \n\n*  讲下项目\n* jvm设置哪些参数，xmx  xms 。给个物理内存，出场景让你设定jvm参数。g1和cms怎么处理在并发标记过程中误标的\n* 说下mysql为什么用B+树，不用b树\n*  innodb和myinsam引擎的区别。myisam适合用于哪些场景\n* 当前读和快照读的原理，给一个场景让判断读到的结果。mysql的锁机制。gap锁怎么加的，gap锁会有什么问题？\n* mysql的sql优化，你看哪些参数。\n*  kafka为社么快，面试官说是大部分顺序写磁盘，其余靠操作系统缓存。java哪个方法实现了零拷贝？\n* kafka消费者挂掉会发生什么？什么情况下会出现？选举机制有没有了解过\n*  为每个线程创建一个单独的实例，怎么实现\n*  并发synchozed和lock区别，synchized升级过程？偏向锁释放了，再来一个线程会变成轻量级锁吗？\n* 如何停止一个线程，使用stop会有什么问题。\n* 合并两个有序链表\n* es线程池参数设置调过没有\n*   分库分表插件，原理了解过没有\n* redis线上问题遇到过没有\n* redis  rehash过程\n* dobbo用过没有\n* 为什么有rpc调用\n* 实现查找附近的人，你怎么设计\n\n# 阿里\n\n* 网络部分\n* TPC/UDP的区别\n* 粘包问题\n* TCP如何确保连接的可靠性\n* TCP 拥塞机制\n* * MySQL\n* 索引存储的数据结构\n* 索引存储在哈希表的情况\n* 使用B+树的优点\n* 最左前缀\n* * Spring\n* Spring的加载过程\n* AOP的使用\n* 反射机制的原理\n# 校招字节\n\n* 介绍项目  \n* map下的实现类，详细介绍  \n* List实现类，详细介绍  \n* 介绍一下AQS  \n* 垃圾回收机制  \n* 线程池参数  \n* b+树  \n* innodb隔离级别  \n* 死锁 \n* 手撕 反转部分链表\n\n*  介绍项目  \n* 类加载机制  \n* syn关键字  \n* 双亲委派  \n* get和post区别  \n* tcp和udp  \n* 拥塞控制  \n* http状态码  \n* 浏览器中输入网址后一系列的事  \n* host文件是在dns解析前还是后使用  \n  * 当时不知道，让我猜一下，我就从让我实现的两个角度说了一下(逗乐了面试官)  \n* 进程线程区别  \n* 手撕 leetcode 54  \n* 100个人坐飞机，第一个人疯了随便坐，后面的人优先坐自己序号位置，如果被占了就随便坐，问第100人正确坐到自己位置概率     \n\n* 1.redis的运行机制，了解多少说多少  \n  * 运行模式，数据结构，持久化机制等，然后以下展开  \n* 集群模式和哨兵模式有啥区别，选举过程，raft协议，gossip协议  \n* 为什么不在从节点内部进行投票选举，qwq这里不知道  \n* zset结构，跳表+hashtable  \n* rdb和aof区别，aof下always的安全性  \n* redis数据过期策略  \n* redis如何作为分布式锁的 \n* 项目里是如何设计索引的，为什么这样设计  \n* 数据内容过多，如何分页查询，分库分表如何做  \n* 手撕 LeetCode31  \n\n  \n\n# 校招阿里\n\n*  消息队列特性 \n\n* redis删除策略 \n\n* 双删问题 \n\n* list、map、set 分析，使用场景 \n\n* Gc如何判断垃圾 \n\n* ConcurrentHashMap \n\n* 简单的一些并发问题 \n\n* 反转链表递归和迭代 两种实现 \n* 业务需求会关注什么 \n* 数据库如何保证并发安全 \n*  组合和继承 \n* 如何抛空指针异常，如何产生该异常(一个空对象进行方法调用) \n*  如何理解ioc \n* equals和hashcode 3\n*  如何理解线程安全 \n* 编译原理，编辑器设计(懵逼，真没学过) \n* 未来规划，人生理想 \n\n* 你会如何作防爬虫策略 \n* 以淘宝请求展开，越详细越好 \n  * tips：一些推送，广告 逻辑是在哪处理的，不清楚 \n*  innodb数据库的查询流程 \n*  如何优化sql \n* 普通二叉树和b+树的区别 \n* 悲观锁和乐观锁 \n*  volatile和syn关键字区别 \n* spring启动过程 \n* 平时在看哪些书 \n* 什么学习方法\n* 手头有哪几个offer\n\n# 阿里\n\n* jvm内存结构，gc结构，为什么年轻带分两个区域\n\n* 遇到过cpu100吗，怎么排查，介绍下jstack jmap工具\n\n* 看过dubbo源码吗，讲下实现原理\n\n* 做过序列化优化没\n\n* 线程池实现原理，参数，拒绝策略默认有哪些，你们项目中是怎么用的\n\n* rocketmq项目是如何使用的，幂等性怎么做，顺序消费怎么做\n\n* 知道java中有哪些锁吗，悲观锁和乐观锁区别。countdownlatch是干什么的。\n\n* Redis有哪些数据结构 \n\n* threadlocal是什么，在你们项目中是怎么使用的\n\n# 三年腾讯\n\n* 介绍项目, 负责什么模块, 采用什么技术, 解决过什么场景下的问题, 有更好的方式么?\n* TCP、UDP 的区别\n* TCP 拥塞控制如何实现？慢启动、快重传等算法原理\n* 进程和线程的区别\n* 协程介绍\n* 进程之间如何通信 \n* MySQL、Redis 如何做集群\n* InnerDB 相对传统数据库的优势\n* InnerDB 索引底层数据结构是什么？\n* InnerDB 事务如何执行？\n* Paxos 和 Raft 协议会么？（这里答了 ZAB 协议介绍）\n* select/epoll 区别\n* 会其他语言么？\n* （Golang）\n\n\n# 五年饿了么\n* 数据库事务的隔离级别？\n* 事务的几大特性，并谈一下实现原理\n* 如何用redis实现消息的发布订阅？\n* java为什么要在内存结构中设计自己的程序计数器，为什么不使用内核的？\n* 分布式事务2pc的过程？\n* redis是单线程的，为什么会这么快？\n* 谈谈nio的实现，以及netty是如何设计的？\n* 微服务化的时候，什么时候应该拆分，什么情况应该合并\n* 什么时候应该使用消息，什么时候适合接口调用？\n* 分库分表中如果让你设计全局id，如何设计，我回答雪花算法，继续问，百度对雪花算法的优化了解过没，一脸懵逼\n* redis如何进行单机热点数据的统计？\n* redis集群中新加节点以后，如何给新节点分配数据？\n* 如何从含有100亿个整数的文件中找出其中最大的100个？\n\n# 三年字节\n\n* 在涉及支付的接口是如何保证接口的高可用，以及在遇到弱网条件下，发出的请求没有回复怎么办？\n* 消息队列问题，如何保证消息的可靠性，不被重复消费，多个相同的消息，如何保证只消费一次？\n* 你负责的功能模块的UV怎么去做的？对于某些某段时间内求情次数非常大的用户如何去处理呢？\n* Redis基本数据类型底层是怎么去实现的？有了解过吗？\n* 在浏览器输入网址敲下回车后发生了什么？从网址DNS解析到HTTP三次握手等过程\n* 在服务的多节点情况下，如何保证请求不会被分配到坏的节点上去的？\n* Redis分布式锁是怎么做到的？锁的过期时间怎么去设计的？如何保证当前锁不会释放掉其他锁？\n* HTTPS和HTTP的区别，HTTPS是如何防止消息被篡改的呢？HTTPS有用到对称加密吗？哪些地方用到了？\n* 写一个算法题吧，给一个有序的int数组和数组当中元素k，输出元素k在数组当中出现的次数。例如：[2,3,4,5,5,5,6,8] k=5 output:3 要去算法的时间复杂度不超过O(n),也就是说不能去遍历数组了\n* 用两个栈实现一个队列\n\n# 三年字节\n* 描述项目主要功能，你实现了那些功能\n* https建立链接的过程，ssl的流程，如何协商的和加密的\n* 数据交互用的啥json ，xml还有个什么buffer没听清，我们全都用的json统一封装请求响应\n* tcp断开链接过程，为什么客户端要等待2倍最大报文段时间才断开链接？没答上来\n* mysql的undulog，redulog，binlog说一说\n* 索引数据结构，主键索引和非主键索引区别\n* redis常用数据类型你用过那些，为啥快，做了啥优化？项目用到了redis么？以后缓存怎么做？缓存一致性问题，双删，以数据库为基准，达到最终一致性。缓存穿透说说？\n* mq使用场景？咋做到低延时高吞吐的，做了啥优化。回答跑题了，扯到内存节点和磁盘节点去了，还有channel连接池减少创建链接和断开链接的资源损耗。\n* rabbitmq整个流程，咋不直接用mysql做你的那个大文件异步下载呢，回答了第一版定时器扫表的那个比较损耗资源，因为不知道多久扫一次。\n* 服务间调用用的啥。\n* nacos这个注册中心你们自己实现的么，回答用的阿里的组件（感觉面试官是搞php或者go的）\n* 虚拟地址到物理地址的寻址流程？？不会\n* 操作系统java编译流程\n* IO多路复用，回答了redis的请求单线程就用到了这个。有哪些方式？给忘了没答上来？\n* mq优化 零拷贝问题？好像跟高吞吐低延时有关系，没答上来\n* 项目，bbs点赞怎么设计的，redis缓存，评论支持一级评论和二级评论这种么，是的，记录了parentId来明确数据之间的层级关系，以及点赞评论通知目标准确性\n* 算法题，目前有一堆日常的任务，比如任务的id为 1， 2， 3， 给出具体的任务数，比如一个数值N和任务之间的依赖关系。多个任务有依赖关系，被依赖的任务执行完，该任务才能执行，输出一种可执行的任务的顺序1，2 说明 1的执行依赖于2先完成。\n  * 输入参数 int N,int[]  1 2 2 3 3 4 输出 4， 3， 2 ， 1\n  * 输入参数 4 ，1 2 2 1 3 4 输出 -1\n\n# 京东 \n* 自我介绍     \n* 讲一下dubbo这个rpc框架的调用方式\n* dubbo配合zookeeper怎么进行服务注册与发现\n* springboot是怎么读取dubbo.xml文件的，启动spring项目的时候是怎么实例化dubbo里面的类的，分析具体细节与源码\n* zookeeper和eureka注册中心的区别，cap定理，zookeeper选举过程\n* 平时怎么优化mysql的，mysql的索引结构，每个结点怎么存，mysql一张表最大能存多少数据。b+树的树深度怎么计算。叶子结点存了什么\n* 聚簇索引和非聚簇索引的区别与底层原理\n* sychronized关键字底层实现，lock底层实现\n* lock底层AQS怎么实现，CLH队列怎么存储数据，具体细节\n* aqs中的state字段作用，如果这个程序突然挂了，锁着的资源怎么做，aqs里面的执行流程\n* volatile原理，底层怎么可见性和保证有序，说一下mesi缓存一致性协议具体\n* 锁的升级，对象的32位或者64位都存了啥\n* 用过redis么，用redis都做了什么\n* redis的删除策略，过期删除有哪些过期策略\n* redis的持久化，rdb和aof区别，redis服务挂了怎么恢复数据，具体恢复过程\n* redis的选举过程\n* mq的作用，用过哪些\n* hashmap底层原理，为什么线程不安全，扩容的具体思路，有没有线程安全的map\n* 讲一下currenthashmap的原理，1.7和1.8区别，扩容，协助扩容\n* threadlocal源码，怎么解决哈希冲突\n* 场景题，数据库里面有两列数据，id和score，数据量上百万。用线程池创建线程进行多线程累加score，怎么设计。从创建线程池到取数据累加存储结果。\n* 场景题，怎么设计一个高并发接口\n\n\n\n# 雪球\n* 业务\n* 单例模式\n* 线程池适合什么样的场景，有哪些参数，配置的参数有哪些考虑\n* 如何保证请求的顺序和余额扣减不超\n* dubbo调用原理\n* 了解netty吗\n* hashmap\n* 分布式唯一id生成选型有哪些考量\n* 监控怎么做的\n* 聊业务\n* 怎样保证幂等\n* 分布式定时任务，任务分片\n* 遇到过哪些比较棘手的线上问题？\n* 线上问题排查思路\n* 有没有了解过devops\n* 分布式发号器如何调研的，leaf是怎么做的，怎么解决时钟回拨，snowflake的设计\n* 分布式锁考虑过哪些方案\n* 了解过哪些中间件，dubbo的原理，看过源码没\n* 数据迁移时有哪些注意的地方\n* code review如何做的，review时需要注意哪些\n\n\n# Boss\n* 业务\n* 设计秒杀场景\n* 知道哪些情况索引会失效\n* 知道哪些Java的锁\n* 运行时如何发现系统之间订单的不一致\n* 项目中的数据是怎样加密\n* 一条select语句在mysql是怎样执行的\n* 分库情况下的转账交易如何设计\n* 分布式事务怎么处理的\n* 如果让你设计一个订单表，该怎么设计\n* callable和runn2able有什么区别\n* 项目tps多少\n\n# **Opay**\n* 聊业务，聊项目\n* 知道哪里数据库引擎，都有哪些区别\n* innodb事务的ACID，B，B+树，在磁盘读取的时候有什么区别\n* innodb怎么实现行锁，不走索引会不会用到行锁\n* 数据库怎么做数据的持久化\n* mysql如何解决幻读问题\n* jvm内存结构，gc算法区别，常用垃圾回收器区别，jdk8默认垃圾回收器\n* 方法区1.7 1.8差异，如何确认一个对象是可以被回收的，哪些对象可以被标记为gcroot\n* redis分布式锁实现，锁续期问题，redis如何做一个队列，redis如何持久化，rdb如何做到不影响主线程\n* 如何保证缓存和数据库的一致性\n\n# 叮咚\n* 线程的状态，怎么理解线程安全问题\n* 自定义注解怎么实现\n* 泛型\n* nio\n* 类加载机制\n* spring ioc，aop，对象注入有哪几种方式？如何解决循环依赖？\n* 垃圾回收器（生产环境怎么oracle用的）\n* 设计模式（观察者模式）\n* 动态代理\n* oauth2.0步骤\n* elasticsearch 原理，底层数据结构，新增一条数据，能立马查询到吗？\n* mybatis 代理模式怎么实现的？mysql四种隔离级别\n* redis集群生产环境怎么使用的？如果集群三个实例，挂了一个，另外两个还能查到缓存吗？\n* redis的过期删除策略和内存淘汰策略，redis的数据持久化\n* 分布式锁（zookeeper怎么实现）\n* 分布式事务（lcn），\n* 分布式id（雪花算法如何保证集群下的每个实例机器码不重复）\n* docker 如何运行Java项目\n\n# 阿里\n* 项目\n* jvm 内存和运行过程 \n* jvm 调优（实践一下） \n* 四种线程实现方式 \n* Runnable 和 Thread 关系，和 Callable、FutureTask 关系，讲讲1.8 中 Future 有什么改进，或者有什么新类？\n* jvm 调参问题（看书） \n* Java IO 方面（没学） \n* 缓存一致性问题 \n* hashmap 为什么用[红黑树](http:///jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91)不用avl树？ \n* 反问：怎么学习？除了基础以外，还得加强实践和积累 \n\n* 项目\n* 讲讲面向对象吧 \n* 讲讲你对 Spring 的理解 \n* IoC 和 AOP 讲一下 \n* 自己对学习的规划 \n* 反问：评价面试（部门不让评价），部门技术栈，业务。\n* 项目和比赛（没有比赛） \n* [redis 为什么快？ \n* [redis](http:///jump/super-jump/word?word=redis) 集群有用到吗、数据同步？（没有，还没学到） \n* Object 对象中的方法 \n* hashcode 和 equals 方法关系和 为啥重写 equals 还要重写 hashcode 呢？ \n* hashmap put 方法流程，和线程不安全问题引出相关 安全的 hashmap \n* concurrenthashmap put 流程 \n* 开放性问题：银行排队叫号和超市排队两者区别（我答的是阻塞非阻塞）\n* 自我介绍一下\n* 我对三次面试的总结：\n  * 对这几场面试用精炼的词语总结一下\n  * 对三场面试官评价，和通过和他们的聊天，谈谈对三次面试的反思\n* 对自己评价\n* 成绩怎么样（不太行）\n* 平时学习怎么学习的？\n* 对你当时阿里笔试的题目有过回顾吗？\n\n# 美团\n\n* 自我介绍\n* 跳槽还蛮频繁的，是什么原因\n* 介绍一下做过的项目\n* 介绍一下广告系统怎么实现，有哪些功能，召回流程是怎样的，过滤是干嘛用的\n* 为什么曝光统计用es去做，为什么不用mysql\n* es的geo circle是什么，有什么作用\n* 为什么用redis做缓存，为什么不用本地缓存\n* 为什么用rocketmq消费打点，技术选型怎么考虑的\n* rocketmq和kafka的区别，各自底层是怎么实现的\n* 笔试题：手写BlockingQueue\n* 自我介绍\n* 介绍一下广告系统，在纸上画一下整个链路的流程图\n* 投放的广告类型有哪些，竞价排名还是包段？\n* 代码/性能优化怎么做的，过滤模块怎么设计的\n* 运营投放广告的策略是什么样的\n* 介绍一下电商项目\n* 笔试题：字符串转数字\n* 笔试题：两个有序链表合并\n* 笔试题：三个有序链表合并\n* 介绍了美团的团队情况\n* 自我介绍\n* 怪兽上市了，为啥考虑美团\n* 讲一下广告系统\n* 运营有哪些方式统计广告收益\n* 原来的接口耗时是多少，现在又是多少，原来性能差的原因是什么，支持的最大qps是多少\n* 广告日曝光量在多少量级\n* 介绍一下电商项目\n* 笔试题：身高排序，不知道具体身高，只知道两两之间的顺序关系(A >B  A > C  C > B B > D)\n* 说一说自我评价：最大的优点是啥，缺点是啥\n* 问了职业生涯规划\n* 对怪兽最喜欢的企业文化是什么，最不喜欢的又是什么\n* 觉得身为程序员，最需要的能力是什么(空杯心态，持续学习，抽象思维，团队协作，复盘总结能力)\n* 薪资期望如何\n* 最近还有没有别的面试\n* 现在住在哪，有没有落户\n* Maven依赖冲突怎么解决\n* Spring IOC 有哪些扩展点\n* java SPI机制\n* java历史上有三次破坏双亲委派模型，是哪三次\n\n# 阿里\n\n* 介绍一下你做过最复杂的项目和线上解决过的问题。\n  * SQL调优。OOM。秒单优化。\n  * 你对这个项目做过的最大贡献是什么？\n  * 这个项目带给你哪些挑战和成长了？\n* 如何保证系统的稳定性？\n  * 限流，降级熔断，多节点，报警信息。\n* 限流算法有那些？\n  * 令牌桶设置为10 代表 QPS最大是10吗？\n  * 如何选择集群限流和单体限流？（都用上）\n  * 熔断降级区别是什么？\n  * 除了这些你还有什么想要补充的吗？\n* 分布式事务\n  * 你们项目中的解决方案\n  * 说一种你认为QPS 最高的分布式事务的解决方案。\n* redis\n  * 项目中redis用来做什么了？\n  * redis 还能干嘛。（说了一下五种数据结构的用途，还有分布式锁。）\n  * redis 单线程为啥快？多线程会有哪些问题？\n  * 分布式锁聊一下。\n  * redis 如何实现 可重入锁？\n* MQ\n  1. MQ在项目中的用途。\n  * 消息写不进去怎么办？\n  * 消息消费不了怎么办？\n  * 消息什么情况下消息会出现丢失的情况？\n  * 什么时候消息会出现重新投递的情况。\n  * 顺序消息如何保证？ 如果不写入同一个queue如何保证消息顺序消费？\n* RocketMQ 为什么快？\n    * mmap 和 sendfile 区别。\n    * DMA getter 机制的引入。\n* 分库分表了解过吗？\n    * 如何分库分表？\n* DDD 了解过吗？\n* 有什么想问我的？\n    * 对我的建议？\n    * 技术热情度很高，我面试那么久了，你是最高的，因为你所在公司的原因，你接触的 项目也没有什么大促之类的，所以导致你考虑问题的时候没有那么的全面。平台对你很重要，我们程序员不仅仅需要关注技术，更多需要去关注业务。有时候业务甚至比我们技术重要。\n\n# 蚂蚁\n* 聊聊你做过的项目中比较有难度的问题，你是怎么解决的？\n* 你用到了mongodb，是怎么解决大数据量下读写效率的？\n* 为什么用mongodb存储而没有选择mysql？\n* MySql的索引有哪些？聚簇索引和非聚簇索引有什么区别？\n* 如何优化一个sql？\n* 说下什么是最左匹配？\n* 单机场景下，如何解决并发问题？\n* Reentrantlock，和ReentrantWriteReadlock 有什么区别？\n* 从线程安全角度来聊下string,stringbuffer和stringbuilder有什么区别？\n* 分布式场景下如何解决并发安全问题？redis和zk具体是怎么实现分布式锁的？\n* 事务有哪些特性？怎么理解本地事务和分布式事务？\n* 能聊下TCC吗？\n* 说下springioc的原理和事务传播行为哪些?\n* static变量，static静态代码块，构造函数，执行顺序？\n* 怎么理解rocketmq推拉模式？\n* 如何保证消息的可靠性？\n* 了解过RPC框架吗？\n* Get请求和Post请求有什么区别？\n* Http和Https有什么区别？\n* 说下Hashmap在put的时候执行流程？\n* Hashmap put的时候，key能等于null吗\n* Hashmap为什么要重写hashcode和equals方法\n* 说下常用的linux命令\n\n# 中通\n* Synchronize1原理\n* Synchronize是重入锁吗？原理是什么？\n* Synchronize的锁升级\n* Synchronize和Reentrantlock区别\n* AQS了解吗\n* 线程池有哪些参数？\n* 线程池原理\n* Threadlocal在项目中的应用场景，内存泄露\n* Java 引用类型\n* HashMap线程不安全具体体现在哪？1.8以后优化了哪些？\n* List的查询时间复杂度多少？双向链表和单向链表相比有哪些优缺点？\n* ConcurrentHashMap是怎么解决线程不安全的问题？和HashTable相比优点是什么？\n* 类加载过程，类加载机制（双亲委派机制）\n* JVM内存模型，哪些是线程私有的，哪些是线程共享的\n* 现在生产环境用的是什么垃圾回收器？\n* 你有没有解决过生产环境的jvm调优问题？\n* MySQL乐观锁和悲观锁\n* Mysql索引类型有哪些？\n* 主键索引和唯一索引一样吗？\n* 说一下sql优化一般都怎么做\n* explain哪些核心参数\n* Mybatis 一级缓存，二级缓存\n* 工厂模式有哪些？\n* Spring和JDK中有用到哪些设计模式？\n* 说说你项目中有用到哪些设计模式？\n* 静态代理和动态代理的区别？\n* 动态代理有哪几种，区别是什么？\n* 如何解决Spring的循环依赖？\n* Spring的AOP，过滤器，拦截器执行顺序？\n* Spring如何获取上下文？\n* Spring中enable注解的实现原理？例如EnableEurake\n* Redis中bitmap应用场景？\n* 按月登录统计，有的月28天，有的30天怎么解决？\n* 你项目中Redis用到了哪些数据结构？\n* Redis GEO类型用法？\n* Redis 一个key最大存储多大数据？\n* 你项目中Redis集群用的是什么？\n* 主从复制和Redis Cluster有什么区别？\n* Redis Cluster负载均衡原理是什么？\n* 说说数据库，redis，zookeeper实现分布式锁有什么区别？\n* zookeeper的节点类型\n* zookeeper的Paxos算法和zab协议\n* Cap理论有了解吗？zookeeper是cp还是ap？\n* Eurake的原理有看过吗？\n* 为什么Eurake那么快？\n* Eurake和zookeeper作为注册有什么区别？\n* Eurake挂了，a服务还能调到b服务吗？\n* 聊一下springcloud的组件？\n* Ribbon的负载均衡策略有哪些？\n* Ribbon是怎么实现灰度发布的？\n* 聊聊RocketMQ的架构\n* RocketMQ如何发送顺序消息？\n* RocketMQ如何解决消息挤压？\n* 生产者发送消息失败了怎么处理？\n* 聊聊kafka的架构\n* kafka从节点能写数据吗？\n* kafka从节点怎么同步数据的？\n* 有用过es吗？倒排算法知道吗？\n* 说一个项目中用技术解决的一个难题\n* 画一下现在的系统架构吧\n\n# 比特大陆\n* 为什么项目采用Dubbo,和springcloud的区别\n* 接上，dubbo协议和http协议区别\n* mysql建表如果不声明主键会怎么样，为什么一般要主动声明主键\n* mysql表是越小越好吗，为什么\n* Redis数据结构，持久化方式有哪几种，主从复制流程\n* Spring注入方式有哪几种\n* K8s作用是什么，为什么要采用K8s，和xx（没听清）区别是什么\n* 项目发布流程是怎么样的。\n\n\n# 美团\n\n* ThreadLocal 里为啥要用 WeakReference。\n*  Tomcat 为什么要自定义 ClassLoader、为什么要破坏双亲委派\n* Lombok 实现原理。AnnotationProcessing，抽象语法树、compile-time解决\n* Spring 循环依赖解决？为啥要用三级缓存来解决？\n* MVCC 为啥要有？  \n* 如何理解 复用\n* 怎样让 java 线程停下来\n\n# Shein \n\n* Java类加载过程，如何加载一个不在classpath下的类\n* Spring：1)@resource 和@Autowire区别 2）如何在spring容器启动后打印一段话 3）BeanFactory 和FactoryBean区别 4）如何自定义starter 5）注解的扫描流程\n* 线程池参数解释，分析从开始到拒绝策略流程，核心线程可以回收吗\n* 为什么阿里规范不推荐使用Executors创建线程池\n* Redis命令执行流程 ，Redis集群默认多少个slot，怎么分配的，key分配流程\n* 如果让你制定Redis规范你会怎么做，为什么不能声明大key\n* 为什么RocketMQ那么快\n* RocketMQ怎么保证顺序消费，怎么处理消息堆积\n* 场景：实现一个排行榜，有2000w数据，只取top100怎么设计\n* 怎么设计一个微服务系统\n\n# 同花顺\n* 我看你公司用kafka，简历上写的rocketmq，这两者有什么区别\n* kafka你们用来干什么用\n* 线程实现方式有几种：说了四种\n* string,stringbuilder,stringbuffer区别，为什么要用stringbuilder 而不用string\n* 堆和栈的区别\n* hashmap 和 concurrenthashmap什么区别\n* mysql的存储引擎用的哪个，为什么，数据机构怎样的\n* 你们业务上定义异常继承的runtimeexception 为什么不直接继承exception 为什么？\n* 范型用过吗？用在什么场景 ，一个方法后面接了个范型参数代表什么\n* object 里面有什么方法\n* 比较两个对象是否相等，为什么要重写equals，hashcode不用重写吗\n* 浅拷贝和深拷贝的区别\n* java8多了哪些新特性，为什么多出了元空间，有什么用。\n* 抽象类和接口有什么区别\n* 栈溢出和堆溢出如何排查\n* 如何实现顺序打印ab\n* 假设有一百亿的数据，如何找出最小的10个\n* 你有什么想问我的吗\n\n\n# 阿里\n* 说说项目，有哪些难点，如何解决的\n* 你说项目里用到了队列解决循环依赖，如果服务挂了，那岂不是恢复后数据丢失了吗？有什么好的方法吗，给了方案持久化到mysql，过程中说到了redis，问到了redis的一致性数据问题如何解决？假如redis突然挂了，如何保证数据的一致性\n* mysql的乐观锁和悲观锁，项目中如何使用的\n* 生产上线程池如何使用的 \n* 假设核心线程数10，最大线程数20，阻塞队列100，此时来了120个请求，问此时应用中有多少线程在跑\n* redis除了做缓存，还可以做什么？ 延迟队列，那你们项目中如何用到的延迟队列 。 主要达了 zset数据结构属性，轮训，接着继续问，假如redis挂了 一个消息 9点发送，8点半挂了，故障恢复9点半启动redis，如何进行消息补偿\n* mockk框架不同请求针对不同的循环依赖数据，如何判别，保证幂等。\n\n\n# 五年VIVO\n\n- CAS的问题及其解决办法\n\n- 公平非公平锁的实现\n\n- MySQL和Redis里面CAS用在什么地方？\n\n- 说一下MySQL的锁（MDL,Gap,index )..\n\n- 线上集群部分几台频繁GC，怎么处理\n\n- 说一个你觉得有价值的项目，以及你在里面做的事情；\n\n- 讲一下上面你提到的DDD过程（战略、战术设计）\n\n- 这次换工作原因?\n\n- 对我们还有什么问题？\n\n# 金蝶\n* springmvc工作流程\n* spring ioc,aop\n* JDK反射机制提供的代理和CGLIB代理区别\n* 数据库优化\n* 索引失效几种情况\n* 事务失效几种场景\n* springboot自动配置的原理\n* 自定义注解实现原理\n* 线程池参数和使用，拒绝策略有几种\n* jvm\n* 类加载\n* redis\n* springcloud常用组件\n* 消息中间件\n* 对加班的看法\n\n# 引用\n\n[1].[面霸传说](https://shimo.im/docs/VjxxC3WT3ydDKGxh)\n[2].[面试题随记](https://www.cnblogs.com/mrxiaobai-wen/p/15061260.html#4912321)\n[3].[海康威视,浙江大华,科大讯飞](https://blog.csdn.net/sunboylife/article/details/119304836)\n[4].[来看看Offer收割机带回来的面试真题](https://mp.weixin.qq.com/s/HhVCX1b1fToisYVCerGaoA)\n[5].[滴滴CTO五轮面试真是太刺激了,Java高级工程师面经](https://zhuanlan.zhihu.com/p/258056702utm_source=wechat_session&utm_medium=social&utm_oi=761649495153840128)","tags":["面试题","大厂"],"categories":["面试"]},{"title":"手撸Spring源码系列(2)-运用设计模式，实现 Bean 的定义、注册、获取","url":"/2021/08/11/Spring/手撸Spring源码/手撸Spring源码系列(2)-运用设计模式，实现 Bean 的定义、注册、获取/","content":"\n## 摘要\n\n* spring定义了一个容器是用来注册，存放，获取Bean对象\n\n<!--more-->\n\n## Bean定义\n\n```java\npublic class BeanDefinition {\n\t\n    //这里直接存放的是对象的引用\n    private Object bean;\n\n    public BeanDefinition(Object bean) {\n        this.bean = bean;\n    }\n\n    public Object getBean() {\n        return bean;\n    }\n\n}\n```\n\n## 容器Bean工厂\n\n```java\npublic class BeanFactory {\n\n    //实际存放的容器\n    private Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n\t\n    //对外暴露的方法：获取bean\n    public Object getBean(String name) {\n        return beanDefinitionMap.get(name).getBean();\n    }\n\t\n    //对外暴露的方法：注册bean定义到容器\n    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) {\n        beanDefinitionMap.put(name, beanDefinition);\n    }\n\n}\n```\n\n## 测试\n\n```java\npublic class ApiTest {\n\n    @Test\n    public void test_BeanFactory(){\n        // 1.初始化 BeanFactory\n        BeanFactory beanFactory = new BeanFactory();\n\n        // 2.注入bean\n        BeanDefinition beanDefinition = new BeanDefinition(new UserService());\n        beanFactory.registerBeanDefinition(\"userService\", beanDefinition);\n\n        // 3.获取bean\n        UserService userService = (UserService) beanFactory.getBean(\"userService\");\n        userService.queryUserInfo();\n    }\n\n}\n```\n\n## 总结\n\n* 工厂中存放的不是具体的对象，而是对象的定义，工厂只存放**生产资料**，我们通过资料的可以去唯一初始化一个对象。\n* 工厂只暴露两个方法，获取bean+注册bean\n\n## 参考\n\n[1].[带你手写 Spring](https://blog.csdn.net/generalfu/category_11066234.html?spm=1001.2014.3001.5482)\n\n[2].[bugstack 虫洞栈](https://bugstack.cn/md/spring/develop-spring/2021-05-16-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Spring%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html)\n\n[3].[《手撸 Spring》 • 小傅哥.pdf](https://download.csdn.net/download/Yao__Shun__Yu/21009038)\n","tags":["Spring","源码"],"categories":["Spring"]},{"title":"手撸Spring源码系列(1)-实现一个简单的Bean容器","url":"/2021/08/11/Spring/手撸Spring源码/手撸Spring源码系列(1)-实现一个简单的Bean容器/","content":"\n## 摘要\n\n* spring定义了一个容器是用来注册，存放，获取Bean对象\n\n<!--more-->\n\n## Bean定义\n\n```java\npublic class BeanDefinition {\n\t\n    //这里直接存放的是对象的引用\n    private Object bean;\n\n    public BeanDefinition(Object bean) {\n        this.bean = bean;\n    }\n\n    public Object getBean() {\n        return bean;\n    }\n\n}\n```\n\n## 容器Bean工厂\n\n```java\npublic class BeanFactory {\n\n    //实际存放的容器\n    private Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n\t\n    //对外暴露的方法：获取bean\n    public Object getBean(String name) {\n        return beanDefinitionMap.get(name).getBean();\n    }\n\t\n    //对外暴露的方法：注册bean定义到容器\n    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) {\n        beanDefinitionMap.put(name, beanDefinition);\n    }\n\n}\n```\n\n## 测试\n\n```java\npublic class ApiTest {\n\n    @Test\n    public void test_BeanFactory(){\n        // 1.初始化 BeanFactory\n        BeanFactory beanFactory = new BeanFactory();\n\n        // 2.注入bean\n        BeanDefinition beanDefinition = new BeanDefinition(new UserService());\n        beanFactory.registerBeanDefinition(\"userService\", beanDefinition);\n\n        // 3.获取bean\n        UserService userService = (UserService) beanFactory.getBean(\"userService\");\n        userService.queryUserInfo();\n    }\n\n}\n```\n\n## 总结\n\n* 工厂中存放的不是具体的对象，而是对象的定义，工厂只存放**生产资料**，我们通过资料的可以去唯一初始化一个对象。\n* 工厂只暴露两个方法，获取bean+注册bean\n\n## 参考\n\n[1].[带你手写 Spring](https://blog.csdn.net/generalfu/category_11066234.html?spm=1001.2014.3001.5482)\n\n[2].[bugstack 虫洞栈](https://bugstack.cn/md/spring/develop-spring/2021-05-16-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Spring%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html)\n\n[3].[《手撸 Spring》 • 小傅哥.pdf](https://download.csdn.net/download/Yao__Shun__Yu/21009038)\n","tags":["Spring","源码"],"categories":["Spring"]},{"title":"设计模式(B)-结构型模式概述","url":"/2021/01/03/设计模式/设计模式(B)-结构型模式概述/","content":"## 摘要\n\n* 阐述了结构型模式的作用\n* 阐述了结构型模式的七种分类\n\n<!--more-->\n\n## 简介\n\n关注如何将现有类或对象组织在一起形成更加强大的结构，\n\n它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n\n由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n\n## 分类\n\n1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。\n4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。\n5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n\n> 除了适配器模式分为类结构型和对象结构型模式两种，其他全部都属于对象结构型模式。\n\n## 参考\n\n[1].[结构型模式概述（结构型模式的分类](http://c.biancheng.net/view/1357.html)\n\n[2].[结构型模式_百度百科](https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/23005291?fr=aladdin)\n\n[3].[设计模式 —— 结构型模式](https://www.cnblogs.com/simpleito/p/10878865.html)\n\n","tags":["设计模式","结构型模式","概述"],"categories":["设计模式"]},{"title":"Commit规范和Idea插件","url":"/2021/01/02/杂项/Commit规范和Idea插件/","content":"## 摘要\n\n* 在Idea中安装commit模板信息\n* commit规范模板格式介绍\n<!--more-->\n## 简介\n\n此commit规范是基于augular，规范的编写Commit可以在Idea或者命令行中快速定位修改，或者快速定位问题编号等。\n\n## Idea安装插件\n\n> 插件名称：Git Commit Template\n\n安装完成后在commit框点击如下按钮\n\n![image-20210105175612157](https://gitee.com/BothSavage/PicGo/raw/master/image-20210105175612157.png)\n\n模板展示\n\n![image-20210105181008428](https://gitee.com/BothSavage/PicGo/raw/master/image-20210105181008428.png)\n\n## 格式\n\n### 模板\n\n```bash\n<type>(<scope>): <subject>\n// 空一行\n<body>\n// 空一行\n<footer>\n```\n\n### Header\n\n#### type\n\n- **feat：新功能（feature）**\n- **fix：修补bug**\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动,空格,格式化,等等）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动\n- perf: 性能 (提高代码性能的改变)\n- test：增加测试或者修改测试\n- build: 影响构建系统或外部依赖项的更改(maven,gradle,npm 等等)\n- ci: 对CI配置文件和脚本的更改\n- chore：对非 src 和 test 目录的修改\n- revert: Revert a commit\n\n> 最常用的就是feat和fix\n\n#### scope\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同\n\n#### subject\n\nsubject是 commit 目的的简短描述，不超过50个字符，主要介绍此次代码变更的主要内容\n\n### body\n\n本次commit的详细描述\n\n### footer\n\n* Breaking Changes\n\n  不兼容变动\n\n* Closed issues\n\n  关闭的问题号或者其他指示信息\n\n## 例子\n\n**新增功能** \n\n```\n\nfeat(xxx模块): 增加xx功能\n\n新建了xxxx，增加了xxx功能\n\n```\n\n**修改BUG**\n\n```\n\nfeat(xxx模块): 修复了xx问题\n\n这个问题的原因是xxx，已经更改xxx文件中的xxx代码，本地测试通过\n\nCloses #1234\n\n```\n\n\n\n## 参考\n\n[1].[Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\n[2].[Git Commit提交规范和IDEA插件Git Commit Template的使用](https://blog.csdn.net/qq_35854212/article/details/103856299)\n\n","tags":["工具","idea","git"],"categories":["杂项"]},{"title":"Hexo结合Stun静态博客搭建从入门到入土","url":"/2021/01/01/极客时间/24-Java并发编程实战/Ge-24-01-可见性、原子性和有序性问题/","content":"## 摘要\n* 同步，分工，互斥\n* 可见性，原子性，有序性\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 缓存导致的可见性问题\n\n在多核时代，每个CPU都有自己的缓存。当多个线程在不同的CPU上执行的时候，这些线程操作的是不同的CPU缓存\n\n```java\npublic class Test {\n\n  private long count = 0;\n\n  private void add10K() {\n    int idx = 0;\n    while(idx++ < 10000) {\n      count += 1;\n    }\n  }\n\n  public static long calc() {\n\t\t\n    final Test test = new Test();\n\n    // 创建两个线程，执行 add() 操作\n    Thread th1 = new Thread(()->{test.add10K();});\n    Thread th2 = new Thread(()->{test.add10K();});\n\n    // 启动两个线程\n    th1.start();\n    th2.start();\n\n    // 等待两个线程执行结束\n    th1.join();\n    th2.join();\n\n    return count;\n  }\n\n}\n```\n\n假设AB线程同时运行，都读取count=0到自己的CPU缓存里面，进行计算后把count=1都写进了内存，此时进行了两次++操作，但是内存中的结果任然是1。这里就是因为缓存的可见性导致问题。\n\n\n\n## 线程切换带来的原子性问题\n\n\n\n![1636904319578](C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\1636904319578.png)\n\n\n\n## 参考\n\n[1].[01 | 可见性、原子性和有序性问题：并发编程Bug的源头](https://time.geekbang.org/column/article/83682)\n\n","tags":["并发","Java"],"categories":["极客时间"]},{"title":"设计模式(1)-单例模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(1)-单例模式/","content":"## 摘要\n\n* 简单介绍了什么是单例模式\n* 介绍了懒汉式和饿汉式的实现\n* 分析了单例模式出现的场景\n* 用数据库连接池的例子演示了单例模式\n\n\n<!--more-->\n\n## 概念\n\n确保一个类只能有一个实例，并提供一个全局访问点来访问这个实例。\n\n### 要点\n\n* 某一个类只能创建一个一个实例\n* 必须类内部自行创建这个实例\n* 必须向系统提供这个实例，也就是提供一个全局访问点\n\n### 优点\n\n* 保证内存中只有一个实例，减小内存开销\n* 避免对资源的多重占用\n* 设置全局访问点，优化和共享资源的访问\n\n### 缺点\n\n* 扩展困难，如果要扩展除了修改原来的代码没有第二种开发途径，违背开闭原则\n* 单例模式的功能通常都写在一个类中，如果功能设计不合理，则很容易违反单一职责原则\n* 并发测试中不好debug\n\n## 场景\n\n对于Java来说，单例模式的落地就是在JVM中只存在单一实例。\n\n* 需要频繁创建一些类，使用单例可以降低系统的内存压力，减少GC\n* 某类只要求生成一个对象的时候，比如一个班中的班长，一个人的身份证\n\n- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。\n- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如**多线程的线程池、网络连接池**等。\n- 频繁访问数据库或文件的对象。\n- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。\n- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 **Web 中的配置对象、数据库的连接池**等。\n\n## 实现方式\n\n懒汉式\n\n每次访问都需要同步，会影响性能，且消耗更多的资源，这就是懒汉式的缺点\n\n```java\npublic class Lazy{\n    private static volatile Lazy instance;\n    private Lazy(){}\n    //DLC\n    public static getInstance(){\n        if(instance==null){\n            synchronized(Lazy.class){\n                if(instance==null){\n                    instance = new Lazy();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n饿汉式\n\n```java\npublic class Hungry{\n    private static final Hungry instance = new Hungry();\n    private Hungry() {}\n    public static Hungry getInstance() {\n        return instance;\n    }\n}\n```\n\n## 实例\n\n获取数据库连接池\n\n```java\npublic final class DbConnectConfig {\n \n    private static ComboPooledDataSource dataSource;\n \n    static {\n        dataSource = new ComboPooledDataSource();\n        dataSource.setUser(JdbcPropertiesConfig.getUSERNAME());\n        dataSource.setPassword(JdbcPropertiesConfig.getPASSWORD());\n        dataSource.setJdbcUrl(JdbcPropertiesConfig.getDATABASEURL());\n        dataSource.setDriverClass(xxxxxxx);\n        //初始化连接数\n        dataSource.setInitialPoolSize(xxx.getINITIALPOOLSIZE());\n        //最小连接数\n        dataSource.setMinPoolSize(xxx.getMINPOOLSIZE());\n        //最大连接数\n        dataSource.setMaxPoolSize(xxx.getMAXPOOLSIZE());\n        //最长等待时间\n        dataSource.setMaxStatements(xxx.getMAXSTATEMENTS());\n        //最大空闲时间，单位毫秒\n        dataSource.setMaxIdleTime(xxx.getMAXIDLETIME());\n        dataSource.setCheckoutTimeout(5000);\n        dataSource.setUnreturnedConnectionTimeout(20);\n    }\n \n \t//这里使用DLC好一点\n    public synchronized static final Connection getConnection() {\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n        } catch (SQLException e) {\n            System.out.println(\"\\r\\n数据库连接异常\");\n            e.printStackTrace();\n        }\n        return conn;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[单例模式设置mysql数据库连接池](https://blog.csdn.net/sade1231/article/details/81562156)\n\n[2].[单例模式（单例设计模式）详解](http://c.biancheng.net/view/1338.html)\n\n[3].[学习笔记 : Java设计模式之Singleton Pattern](https://ishacker.net/2019/09/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton-Pattern/)\n\n","tags":["demo","设计模式","单例模式"],"categories":["设计模式"]},{"title":"设计模式(2)-原型模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(2)-原型模式/","content":"## 摘要\n\n* 介绍了原型模式的概念\n* 原型模式的优点就是性能比new好\n* 对比了深浅拷贝\n\n<!--more-->\n## 概念\n\n> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 \n\n### 优点\n\n* Java自带的原型模式基于内存二进制流的复制（此时访问权限对原型模式无效），在性能上比直接 new 一个对象更加优良，克隆不会执行构造方法，避免了初始化占有的时间和空间 \n\n### 缺点\n\n* 需要为每一个类都配置一个 clone 方法\n* clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。\n* 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。\n\n## 场景\n\n- 对象之间相同或相似，即只是个别的几个属性不同的时候。\n- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。\n- 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。\n- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。\n\n> 在 Spring中，原型模式应用的非常广泛，例如 scope='prototype'、JSON.parseObject() 等都是原型模式的具体应用。\n\n## 实例\n\n### 浅克隆\n\n```java\npublic class Brand {\n\tpublic void install(){\n\t\tSystem.out.println(\"安装汽车品牌\");\n\t}\n}\n```\n\n```java\n@Data\npublic class Car implements Cloneable{\n\tprivate Brand brand;\n\t\n\tpublic Car(){\n\t\tthis.brand = new Brand();\n\t}\n\t\n\t@Override\n\tprotected Object clone() {\n\t\tCar clone = null;\n\t\ttry {\n\t\t\tclone = (Car)super.clone();\n\t\t} catch (CloneNotSupportedException e) {\n\t\t\tSystem.out.println(\"克隆失败...\");\n\t\t}\n\t\treturn clone;\n\t}\n\t\n\t\n\tpublic void run(){\n\t\tSystem.out.println(\"小汽车能跑了\");\n\t}\n}\n\n```\n\n```java\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCar car,cloneCar;\n\t\tcar = new Car();\n\t\tcloneCar = (Car)car.clone();\n\t\t\n\t\tSystem.out.println(\"car == cloneCar?\");\n\t\tSystem.out.println(car == cloneCar);\n\t\t\n\t\tSystem.out.println(\"car.getBrand() == cloneCar.getBrand()?\");\n\t\tSystem.out.println(car.getBrand() == cloneCar.getBrand());\n\t}\n}\n\n```\n\n### 深克隆\n\n```java\npublic class Brand implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic void install(){\n\t\tSystem.out.println(\"安装汽车品牌\");\n\t}\n}\n\n```\n\n```java\n@Data\npublic class Car implements Serializable{\n\tprivate static final long serialVersionUID = 1L;\n\tprivate Brand brand = null;\n\t\n\tpublic Car(){\n\t\tthis.brand = new Brand();\n\t}\n\t\n\tpublic Object deepClone() throws IOException, ClassNotFoundException{\n\t\t//将对象写入流中\n\t\tByteArrayOutputStream bao=new ByteArrayOutputStream();\n\t\tObjectOutputStream oos=new ObjectOutputStream(bao);\n\t\toos.writeObject(this);\n\t\t\t\t\n\t\t//将对象从流中取出\n\t\tByteArrayInputStream bis=new ByteArrayInputStream(bao.toByteArray());\n\t\tObjectInputStream ois=new ObjectInputStream(bis);\n\t\treturn(ois.readObject());\n\t}\n\tpublic void run(){\n\t\tSystem.out.println(\"小汽车能跑了\");\n\t}\n}\n\n```\n\n```java\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCar car,cloneCar=null;\n\t\tcar = new Car();\n\t\ttry {\n\t\t\tcloneCar = (Car) car.deepClone();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tSystem.out.println(\"car == cloneCar?\");\n\t\tSystem.out.println(car == cloneCar);\n\t\t\n\t\tSystem.out.println(\"car.getBrand() == cloneCar.getBrand()?\");\n\t\tSystem.out.println(car.getBrand() == cloneCar.getBrand());\n\t}\n}\n```\n\n\n\n## 参考\n\n[1].[原型模式（原型设计模式）详解](http://c.biancheng.net/view/1343.html)\n\n[2].[原型模式](https://www.runoob.com/design-pattern/prototype-pattern.html)\n\n[3].[设计模式之原型模式（Java代码实现）](https://baijiahao.baidu.com/s?id=1639108556663038986&wfr=spider&for=pc)\n\n[4].[原型模式（实例）](https://blog.csdn.net/qq_44889069/article/details/106151467)\n\n\n\n","tags":["demo","设计模式","原型模式"],"categories":["设计模式"]},{"title":"设计模式(3)-简单工厂模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(3)-简单工厂模式/","content":"## 摘要\n\n* 简单介绍了什么是简单工厂模式\n* 简单工厂实例\n<!--more-->\n## 概念\n\n> **简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。**\n>\n> 简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。\n\n### 优点\n\n* 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。\n* 客户端无需知道所创建具体产品的类名，只需知道参数即可。\n* 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。\n\n### 缺点\n\n1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。\n2. 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度\n3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂\n4. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。\n\n## 场景\n\n* 产品种类较少的模式\n* 简单工厂模式的客户端只需要传入工厂类的参数，不用关心对象的创建逻辑\n\n## 实现\n\n### 抽象产品\n\n```java\npublic interface Product {\n     void show();\n}\n```\n\n### 具体产品\n\n```java\nclass ConcreteProduct1 implements Product {\n    public void show() {\n    \tSystem.out.println(\"具体产品1显示...\");\n    }\n}\n```\n\n```java\nclass ConcreteProduct2 implements Product {\n    public void show() {\n    \tSystem.out.println(\"具体产品1显示...\");\n    }\n}\n```\n\n```java\nclass SimpleFactory {\n    public static Product makeProduct(int kind) {\n        switch (kind) {\n            case Const.PRODUCT_A:\n                return new ConcreteProduct1();\n            case Const.PRODUCT_B:\n                return new ConcreteProduct2();\n        }\n        return null;\n    }\n}\n\n//辅助常量\nfinal class Const {\n    static final int PRODUCT_A = 0;\n    static final int PRODUCT_B = 1;\n    static final int PRODUCT_C = 2;\n}\n```\n\n## 参考\n\n[1].[简单工厂模式](http://c.biancheng.net/view/8385.html)\n\n[2].[工厂模式--简单工厂模式](https://www.jianshu.com/p/5cb52d84bd6d)\n\n","tags":["demo","设计模式","工厂模式"],"categories":["设计模式"]},{"title":"设计模式(6)-建造者模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(6)-建造者模式/","content":"## 摘要\n\n* 简单介绍了什么是建造者模式\n* 菜鸟教程的小例子\n<!--more-->\n## 概念\n\n> 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\n\n\n\n建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。\n\n### 优点\n\n* 封装性好，构建和表示分离。\n* 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。\n* 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。\n\n### 缺点\n\n* 产品的组成部分必须相同，这限制了其使用范围。\n* 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大\n\n## 场景\n\n* **当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。**\n* 需要生成的对象具有复杂的内部结构\n* 需要生成的对象内部属性本身相互依赖\n\n## 实例\n\n### 文字实例\n\n* 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"\n\n* JAVA 中的 StringBuilder'\n\n### 代码实例\n\n#### 食物条目接口\n\n```java\npublic interface Item {\n   public String name();\n   public Packing packing();\n   public float price();    \n}\n```\n\n#### 食物包装接口\n\n```java\npublic interface Packing {\n   public String pack();\n}\n```\n\n#### 包装接口实体\n\n```java\npublic class Wrapper implements Packing {\n \n   @Override\n   public String pack() {\n      return \"Wrapper\";\n   }\n}\n```\n\n```java\npublic class Bottle implements Packing {\n \n   @Override\n   public String pack() {\n      return \"Bottle\";\n   }\n}\n```\n\n#### 食物条目接口抽象类\n\n```java\npublic abstract class Burger implements Item {\n \n   @Override\n   public Packing packing() {\n      return new Wrapper();\n   }\n \n   @Override\n   public abstract float price();\n}\n```\n\n```java\npublic abstract class ColdDrink implements Item {\n \n    @Override\n    public Packing packing() {\n       return new Bottle();\n    }\n \n    @Override\n    public abstract float price();\n}\n```\n\n#### 食物条目实体\n\n```java\npublic class VegBurger extends Burger {\n \n   @Override\n   public float price() {\n      return 25.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Veg Burger\";\n   }\n}\n```\n\n```java\npublic class ChickenBurger extends Burger {\n \n   @Override\n   public float price() {\n      return 50.5f;\n   }\n \n   @Override\n   public String name() {\n      return \"Chicken Burger\";\n   }\n}\n```\n\n```java\npublic class Coke extends ColdDrink {\n \n   @Override\n   public float price() {\n      return 30.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Coke\";\n   }\n}\n```\n\n```java\npublic class Pepsi extends ColdDrink {\n \n   @Override\n   public float price() {\n      return 35.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Pepsi\";\n   }\n}\n```\n\n#### 菜单实体\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Meal {\n   private List<Item> items = new ArrayList<Item>();    \n \n   public void addItem(Item item){\n      items.add(item);\n   }\n \n   public float getCost(){\n      float cost = 0.0f;\n      for (Item item : items) {\n         cost += item.price();\n      }        \n      return cost;\n   }\n \n   public void showItems(){\n      for (Item item : items) {\n         System.out.print(\"Item : \"+item.name());\n         System.out.print(\", Packing : \"+item.packing().pack());\n         System.out.println(\", Price : \"+item.price());\n      }        \n   }    \n}\n```\n\n#### 实体构造者对象\n\n```java\npublic class MealBuilder {\n \n   public Meal prepareVegMeal (){\n      Meal meal = new Meal();\n      meal.addItem(new VegBurger());\n      meal.addItem(new Coke());\n      return meal;\n   }   \n \n   public Meal prepareNonVegMeal (){\n      Meal meal = new Meal();\n      meal.addItem(new ChickenBurger());\n      meal.addItem(new Pepsi());\n      return meal;\n   }\n}\n```\n\n#### 演示\n\n```java\npublic class BuilderPatternDemo {\n   public static void main(String[] args) {\n      MealBuilder mealBuilder = new MealBuilder();\n \n      Meal vegMeal = mealBuilder.prepareVegMeal();\n      System.out.println(\"Veg Meal\");\n      vegMeal.showItems();\n      System.out.println(\"Total Cost: \" +vegMeal.getCost());\n \n      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();\n      System.out.println(\"\\n\\nNon-Veg Meal\");\n      nonVegMeal.showItems();\n      System.out.println(\"Total Cost: \" +nonVegMeal.getCost());\n   }\n}\n```\n\n\n\n## 参考\n\n[1].[秒懂设计模式之建造者模式（Builder pattern）](https://zhuanlan.zhihu.com/p/58093669)\n\n[2].[建造者模式（Bulider模式）详解](http://c.biancheng.net/view/1354.html)\n\n[3].[建造者模式](https://www.runoob.com/design-pattern/builder-pattern.html)\n\n","tags":["demo","设计模式","建造者模式"],"categories":["设计模式"]},{"title":"设计模式(5)-抽象工厂模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(5)-抽象工厂模式/","content":"## 摘要\n\n* 简单介绍了额超级工厂(抽象工厂)的概念\n* 实现一个小Demo\n<!--more-->\n## 概念\n\n> 是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。\n>\n\n### 优点\n\n* 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\n* 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。\n* 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。\n\n### 缺点\n\n* 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。\n\n## 场景\n\n- 创建对象的最佳方式\n\n## 实例\n\n### 抽象产品A\n\n```java\npublic interface ProductA {\n   void do();\n}\n```\n\n### 抽象产品A实现A,B,C\n\n```java\npublic class ProductAImplA implements ProductA {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductAImplA\");\n   }\n}\n```\n\n```java\npublic class ProductAImplB implements ProductA {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductAImplB\");\n   }\n}\n```\n\n```java\npublic class ProductAImplC implements ProductA {\n \n   @Override\n   public void do() {\n      System.out.println(\"IProductAImplC\");\n   }\n}\n```\n\n### 抽象产品B\n\n```java\npublic interface ProductB {\n   void do();\n}\n```\n\n### 抽象产品B实现A,B,C\n\n```java\npublic class ProductBImplA implements ProductB {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductBImplA\");\n   }\n}\n```\n\n```java\npublic class ProductBImplB implements ProductB {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductBImplB\");\n   }\n}\n```\n\n```java\npublic class ProductBImplC implements ProductB {\n \n   @Override\n   public void do() {\n      System.out.println(\"ProductBImplC\");\n   }\n}\n```\n\n### 抽象工厂\n\n```java\npublic abstract class AbstractFactory {\n   public abstract ProductA getProductA(String name);\n   public abstract ProductB getProductB(String name) ;\n}\n```\n\n### 工厂实例\n\n```java\npublic class ProductAFactory extends AbstractFactory {\n    \n   @Override\n   public Shape getProductA(String name){\n      if(name == null){\n         return null;\n      }        \n      if(name.equalsIgnoreCase(\"getProductAImplA\")){\n         return new getProductAImplA();\n      } else if(name.equalsIgnoreCase(\"getProductAImplB\")){\n         return new getProductAImplB();\n      } else if(name.equalsIgnoreCase(\"getProductAImplC\")){\n         return new getProductAImplC();\n      }\n      return null;\n   }\n   \n   @Override\n   public Color getProductB(String name) {\n      return null;\n   }\n}\n```\n\n```java\npublic class ProductBFactory extends AbstractFactory {\n    \n   @Override\n   public Shape getProductA(String name){\n      return null;\n   }\n   \n   @Override\n   public Color getProductB(String name) {\n      if(name == null){\n         return null;\n      }        \n      if(name.equalsIgnoreCase(\"getProductBImplA\")){\n         return new getProductBImplA();\n      } else if(name.equalsIgnoreCase(\"getProductBImplB\")){\n         return new getProductBImplB();\n      } else if(name.equalsIgnoreCase(\"getProductBImplC\")){\n         return new getProductBImplC();\n      }\n      return null;\n   }\n}\n```\n\n### 工厂创造器\n\n```java\npublic class FactoryProducer {\n   public static AbstractFactory getFactory(String choice){\n      if(choice.equalsIgnoreCase(\"ProductAFactory\")){\n         return new ProductAFactory();\n      } else if(choice.equalsIgnoreCase(\"ProductBFactory\")){\n         return new ProductBFactory();\n      }\n      return null;\n   }\n}\n```\n\n## 参考\n\n[1].[抽象工厂模式](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)\n\n[2].[抽象工厂模式（详解版）](http://c.biancheng.net/view/1351.html)\n\n[3].[抽象工厂模式和工厂模式的区别？](https://www.zhihu.com/question/20367734)\n\n\n\n","tags":["demo","设计模式","工厂模式"],"categories":["设计模式"]},{"title":"设计模式(4)-工厂方法模式","url":"/2020/12/30/设计模式/创建型模式/设计模式(4)-工厂方法模式/","content":"## 摘要\n\n* 工厂方法模式就是把工厂也做抽象\n* 一个工厂方法模式的小实例\n<!--more-->\n## 概念\n\n> 对简单工厂方式的进一步抽象，在不改变原来的代码情况下去引入新的产品，满足开闭原则\n\n### 优点\n\n* 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。\n* 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。\n* 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。\n\n### 缺点\n\n* 类的个数容易过多，增加复杂度\n* 增加了系统的抽象性和理解难度\n* 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。\n\n## 场景\n\n* 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。\n* 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。\n* 客户不关心创建产品的细节，只关心产品的品牌\n\n## 实例\n\n### 产品的抽象\n\n```java\ninterface Product {\n    public void show();\n}\n```\n### 产品的实现\n\n```java\nclass ConcreteProduct1 implements Product {\n    public void show() {\n        System.out.println(\"具体产品1显示...\");\n    }\n}\n\nclass ConcreteProduct2 implements Product {\n    public void show() {\n        System.out.println(\"具体产品2显示...\");\n    }\n}\n```\n### 工厂的抽象\n```java\ninterface AbstractFactory {\n    public Product newProduct();\n}\n```\n### 工厂的实现\n```java\nclass ConcreteFactory1 implements AbstractFactory {\n    public Product newProduct() {\n        System.out.println(\"具体工厂1生成-->具体产品1...\");\n        return new ConcreteProduct1();\n    }\n}\n\nclass ConcreteFactory2 implements AbstractFactory {\n    public Product newProduct() {\n        System.out.println(\"具体工厂2生成-->具体产品2...\");\n        return new ConcreteProduct2();\n    }\n}\n```\n\n## 扩展\n\n> * 简单工厂模式就是只有一个产品，不需要多余的工厂\n> * 在多个产品种类的需求下，为每一种产品定义一种工厂类\n\n## 参考\n\n[1].[工厂方法模式（详解版）](http://c.biancheng.net/view/1348.html)\n\n[2].[设计模式之工厂方法模式](https://blog.csdn.net/weixin_40388441/article/details/109493785)","tags":["demo","设计模式","工厂模式"],"categories":["设计模式"]},{"title":"设计模式(1)-单例模式","url":"/2020/12/30/设计模式/设计模式(1)-单例模式/","content":"## 摘要\n\n* 简单介绍了什么是单例模式\n* 介绍了懒汉式和饿汉式的实现\n* 分析了单例模式出现的场景\n* 用数据库连接池的例子演示了单例模式\n\n\n<!--more-->\n\n## 概念\n\n确保一个类只能有一个实例，并提供一个全局访问点来访问这个实例。\n\n### 要点\n\n* 某一个类只能创建一个一个实例\n* 必须类内部自行创建这个实例\n* 必须向系统提供这个实例，也就是提供一个全局访问点\n\n### 优点\n\n* 保证内存中只有一个实例，减小内存开销\n* 避免对资源的多重占用\n* 设置全局访问点，优化和共享资源的访问\n\n### 缺点\n\n* 扩展困难，如果要扩展除了修改原来的代码没有第二种开发途径，违背开闭原则\n* 单例模式的功能通常都写在一个类中，如果功能设计不合理，则很容易违反单一职责原则\n* 并发测试中不好debug\n\n## 场景\n\n对于Java来说，单例模式的落地就是在JVM中只存在单一实例。\n\n* 需要频繁创建一些类，使用单例可以降低系统的内存压力，减少GC\n* 某类只要求生成一个对象的时候，比如一个班中的班长，一个人的身份证\n\n- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。\n- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如**多线程的线程池、网络连接池**等。\n- 频繁访问数据库或文件的对象。\n- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。\n- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 **Web 中的配置对象、数据库的连接池**等。\n\n## 实现方式\n\n懒汉式\n\n每次访问都需要同步，会影响性能，且消耗更多的资源，这就是懒汉式的缺点\n\n```java\npublic class Lazy{\n    private static volatile Lazy instance;\n    private Lazy(){}\n    //DLC\n    public static getInstance(){\n        if(instance==null){\n            synchronized(Lazy.class){\n                if(instance==null){\n                    instance = new Lazy();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n饿汉式\n\n```java\npublic class Hungry{\n    private static final Hungry instance = new Hungry();\n    private Hungry() {}\n    public static Hungry getInstance() {\n        return instance;\n    }\n}\n```\n\n## 实例\n\n获取数据库连接池\n\n```java\npublic final class DbConnectConfig {\n \n    private static ComboPooledDataSource dataSource;\n \n    static {\n        dataSource = new ComboPooledDataSource();\n        dataSource.setUser(JdbcPropertiesConfig.getUSERNAME());\n        dataSource.setPassword(JdbcPropertiesConfig.getPASSWORD());\n        dataSource.setJdbcUrl(JdbcPropertiesConfig.getDATABASEURL());\n        dataSource.setDriverClass(xxxxxxx);\n        //初始化连接数\n        dataSource.setInitialPoolSize(xxx.getINITIALPOOLSIZE());\n        //最小连接数\n        dataSource.setMinPoolSize(xxx.getMINPOOLSIZE());\n        //最大连接数\n        dataSource.setMaxPoolSize(xxx.getMAXPOOLSIZE());\n        //最长等待时间\n        dataSource.setMaxStatements(xxx.getMAXSTATEMENTS());\n        //最大空闲时间，单位毫秒\n        dataSource.setMaxIdleTime(xxx.getMAXIDLETIME());\n        dataSource.setCheckoutTimeout(5000);\n        dataSource.setUnreturnedConnectionTimeout(20);\n    }\n \n \t//这里使用DLC好一点\n    public synchronized static final Connection getConnection() {\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n        } catch (SQLException e) {\n            System.out.println(\"\\r\\n数据库连接异常\");\n            e.printStackTrace();\n        }\n        return conn;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[单例模式设置mysql数据库连接池](https://blog.csdn.net/sade1231/article/details/81562156)\n\n[2].[单例模式（单例设计模式）详解](http://c.biancheng.net/view/1338.html)\n\n[3].[学习笔记 : Java设计模式之Singleton Pattern](https://ishacker.net/2019/09/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton-Pattern/)\n\n","tags":["demo","设计模式","单例模式"],"categories":["设计模式"]},{"title":"设计模式(0)-入门","url":"/2020/12/30/设计模式/设计模式(0)-入门/","content":"## 摘要\n\n* 简述了设计模式是什么以及优点\n* 按照目的和作用范围进行了划分\n* 介绍了23种设计模式\n\n\n<!--more-->\n\n## 简介\n\n目前软件工程的设计模式主要是23种，可以根据模式的目的和模式的作用范围进行分类。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性以及类之间的关联关系和组合关系的充分理解。\n\n优点\n\n* 思维能力，编程能力，设计能力\n* 设计标准化，代码编制工程化\n* 保证代码可重复用性，可读性，可靠性，灵活性，可维护性\n\n## 分类\n\n* 目的划分\n  * 创建型模式\n    * 将对象的创建与使用分离\n    * 五种创建模式\n      * 单例\n      * 原型\n      * 工厂方法\n      * 抽象工厂\n      * 建造者\n  * 结构型模式\n    * 描述如何将类或对象以某种布局组成更大的结构\n    * 七种结构型模式\n      * 代理\n      * 适配器\n      * 桥接\n      * 装饰\n      * 外观\n      * 享元\n      * 组合\n  * 行为型模式\n    * 描述类或者对象之间相互协作共同完成单个对象无法完成的任务，以及职责划分\n    * 十一种行为型模式\n      * 模板方法\n      * 策略\n      * 命令\n      * 职责链\n      * 状态\n      * 观察者\n      * 中介者\n      * 迭代器\n      * 访问者\n      * 备忘录\n      * 解释器\n* 作用范围划分\n  * 类模式\n    * 处理类和子类的关系，这些关系通过继承来建立，是静态的，编译时刻就稳定下来了\n    * 四种类模式\n      * (类)适配器\n      * 模板方法\n      * 解释器\n      * 工厂方法\n  * 对象模式\n    * 用于处理对象之间的关系，这些关系可以通过组合或者聚合来实现，在运行时刻是可以变化的具有动态性\n    * 十九种对象模式\n\n## 具体介绍\n\n1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。\n10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。\n18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n## 参考\n\n[1].[GoF 的 23 种设计模式的分类和功能](http://c.biancheng.net/view/1320.html)\n\n[2].[软件设计模式概述](http://c.biancheng.net/view/1317.html)\n\n\n\n","tags":["设计模式","入门"],"categories":["设计模式"]},{"title":"SpringBoot系列(1)——AOP-3-实战1-权限&日志","url":"/2020/12/29/SpringBoot/SpringBoot系列(1)——AOP-3-实战1-权限&日志/","content":"## 摘要\n\n* 实现简单的权限控制\n* 实现简单的日志\n\n\n<!--more-->\n\n## 权限控制\n\n### pom\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface PermissionAnnotation{}\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\n@Order(1)\npublic class PermissionFirstAdvice {\n\n    @Pointcut(\"@annotation(xx.xx.xx.PermissionAnnotation)\")\n    private void permissionCheck() {\n    }\n\n    @Around(\"permissionCheck()\")\n    public Object permissionCheckFirst(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(System.currentTimeMillis());\n\n        //获取请求参数\n        Object[] objects = joinPoint.getArgs();\n        String userName = (String) objects[0];\n\n        if (!userName.equals(\"admin\")) {\n            return \"失败\";\n        }\n        return joinPoint.proceed();\n    }\n}\n```\n\n### controller\n\n```java\n@RestController\n@RequestMapping(value = \"/permission\")\npublic class TestController {\n    \n    @RequestMapping(value = \"/check\", method = RequestMethod.POST)\n    @PermissionsAnnotation()\n    public String getGroupList(@RequestParam String userName) {\n        return \"Hello \"+userName;\n    }\n}\n```\n\n## 日志\n\n### pom\n\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.5.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.70</version>\n        </dependency>\n    </dependencies>\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\npublic class OperLogAspect {\n\n    //操作切入点\n    @Pointcut(\"@annotation(com.bothsavage.annotation.OperLog)\")\n    public void operLogPoinCut() {}\n\n\n    //正常返回通知\n    @AfterReturning(value = \"operLogPoinCut()\", returning = \"keys\")\n    public void saveOperLog(JoinPoint joinPoint, Object keys) {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);\n        OperationLog operlog = new OperationLog();\n        try {\n            MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n            Method method = signature.getMethod();\n            String className = joinPoint.getTarget().getClass().getName();\n            String methodName = method.getName();\n            OperLog opLog = method.getAnnotation(OperLog.class);\n            methodName = className + \".\" + methodName;\n            Map<String, String> rtnMap = converMap(request.getParameterMap());\n            String params = JSON.toJSONString(rtnMap);\n\n            operlog.setOperId(IdUtil.randomUUID());\n            operlog.setOperModul(opLog.operModul());\n            operlog.setOperType(opLog.operType());\n            operlog.setOperDesc(opLog.operDesc());\n            operlog.setOperMethod(methodName); // 请求方法\n            operlog.setOperRequParam(params); // 请求参数\n            operlog.setOperRespParam(JSON.toJSONString(keys)); // 返回结果\n            operlog.setOperUri(request.getRequestURI()); // 请求URI\n            operlog.setOperCreateTime(new Date()); // 创建时间\n\n            //打印日志\n            System.out.println(JSON.toJSONString(operlog));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n        //转换request 请求参数\n    public Map<String, String> converMap(Map<String, String[]> paramMap) {\n        Map<String, String> rtnMap = new HashMap<String, String>();\n        for (String key : paramMap.keySet()) {\n            rtnMap.put(key, paramMap.get(key)[0]);\n        }\n        return rtnMap;\n    }\n\n    //转换异常信息为字符串\n    public String stackTraceToString(String exceptionName, String exceptionMessage, StackTraceElement[] elements) {\n        StringBuffer strbuff = new StringBuffer();\n        for (StackTraceElement stet : elements) {\n            strbuff.append(stet + \"\\n\");\n        }\n        String message = exceptionName + \":\" + exceptionMessage + \"\\n\\t\" + strbuff.toString();\n        return message;\n    }\n}\n```\n\n### 实体类\n\n```java\npackage com.bothsavage.entity;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\npublic class OperationLog {\n    private String operId;\n    private String operModul;\n    private String operType;\n    private String operDesc;\n    private String OperMethod;\n    private String OperRequParam;\n    private String OperRespParam;\n    private String OperUserId;\n    private String OperUserName;\n    private String OperIp;\n    private String OperUri;\n    private Date OperCreateTime;\n    private String OperVer;\n}\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD) //注解放置的目标位置,METHOD是可注解在方法级别上\n@Retention(RetentionPolicy.RUNTIME) //注解在哪个阶段执行\n@Documented\npublic @interface OperLog {\n    String operModul() default \"\"; // 操作模块\n    String operType() default \"\";  // 操作类型\n    String operDesc() default \"\";  // 操作说明\n}\n```\n\n### controller\n\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/test/{testName}\")\n    @OperLog(operModul = \"测试模块\",operType = \"test\",operDesc = \"这个是用来测试的\")\n    public String test(@PathVariable String testName){\n        return  \"hello\"+testName;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[把自己牛逼到了，在SpringBoot用AOP切面实现一个权限校验...](https://mp.weixin.qq.com/s/2e8x9n4p49kZzM2Fr2cTVw)\n\n[2].[Spring AOP 实现功能权限校验功能](https://blog.csdn.net/houxuehan/article/details/51745175?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&spm=1001.2101.3001.4242)\n\n[3].[SpringAop实现权限校验与日志打印](https://blog.csdn.net/sinat_34620530/article/details/103993158?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control)\n\n[4].[基于Spring AOP实现的权限控制](https://www.cnblogs.com/sxkgeek/p/9985929.html)\n\n[5].[使用SpringBoot AOP 记录操作日志、异常日志](https://www.cnblogs.com/wm-dv/p/11735828.html)\n\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(3)——AOP实战1-权限&日志","url":"/2020/12/29/SpringBoot/SpringBoot系列(3)——AOP实战1-权限&日志/","content":"## 摘要\n\n* 实现简单的权限控制\n* 实现简单的日志\n\n\n<!--more-->\n\n## 权限控制\n\n### pom\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface PermissionAnnotation{}\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\n@Order(1)\npublic class PermissionFirstAdvice {\n\n    @Pointcut(\"@annotation(xx.xx.xx.PermissionAnnotation)\")\n    private void permissionCheck() {\n    }\n\n    @Around(\"permissionCheck()\")\n    public Object permissionCheckFirst(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(System.currentTimeMillis());\n\n        //获取请求参数\n        Object[] objects = joinPoint.getArgs();\n        String userName = (String) objects[0];\n\n        if (!userName.equals(\"admin\")) {\n            return \"失败\";\n        }\n        return joinPoint.proceed();\n    }\n}\n```\n\n### controller\n\n```java\n@RestController\n@RequestMapping(value = \"/permission\")\npublic class TestController {\n    \n    @RequestMapping(value = \"/check\", method = RequestMethod.POST)\n    @PermissionsAnnotation()\n    public String getGroupList(@RequestParam String userName) {\n        return \"Hello \"+userName;\n    }\n}\n```\n\n## 日志\n\n### pom\n\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.5.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.70</version>\n        </dependency>\n    </dependencies>\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\npublic class OperLogAspect {\n\n    //操作切入点\n    @Pointcut(\"@annotation(com.bothsavage.annotation.OperLog)\")\n    public void operLogPoinCut() {}\n\n\n    //正常返回通知\n    @AfterReturning(value = \"operLogPoinCut()\", returning = \"keys\")\n    public void saveOperLog(JoinPoint joinPoint, Object keys) {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);\n        OperationLog operlog = new OperationLog();\n        try {\n            MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n            Method method = signature.getMethod();\n            String className = joinPoint.getTarget().getClass().getName();\n            String methodName = method.getName();\n            OperLog opLog = method.getAnnotation(OperLog.class);\n            methodName = className + \".\" + methodName;\n            Map<String, String> rtnMap = converMap(request.getParameterMap());\n            String params = JSON.toJSONString(rtnMap);\n\n            operlog.setOperId(IdUtil.randomUUID());\n            operlog.setOperModul(opLog.operModul());\n            operlog.setOperType(opLog.operType());\n            operlog.setOperDesc(opLog.operDesc());\n            operlog.setOperMethod(methodName); // 请求方法\n            operlog.setOperRequParam(params); // 请求参数\n            operlog.setOperRespParam(JSON.toJSONString(keys)); // 返回结果\n            operlog.setOperUri(request.getRequestURI()); // 请求URI\n            operlog.setOperCreateTime(new Date()); // 创建时间\n\n            //打印日志\n            System.out.println(JSON.toJSONString(operlog));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n        //转换request 请求参数\n    public Map<String, String> converMap(Map<String, String[]> paramMap) {\n        Map<String, String> rtnMap = new HashMap<String, String>();\n        for (String key : paramMap.keySet()) {\n            rtnMap.put(key, paramMap.get(key)[0]);\n        }\n        return rtnMap;\n    }\n\n    //转换异常信息为字符串\n    public String stackTraceToString(String exceptionName, String exceptionMessage, StackTraceElement[] elements) {\n        StringBuffer strbuff = new StringBuffer();\n        for (StackTraceElement stet : elements) {\n            strbuff.append(stet + \"\\n\");\n        }\n        String message = exceptionName + \":\" + exceptionMessage + \"\\n\\t\" + strbuff.toString();\n        return message;\n    }\n}\n```\n\n### 实体类\n\n```java\npackage com.bothsavage.entity;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\npublic class OperationLog {\n    private String operId;\n    private String operModul;\n    private String operType;\n    private String operDesc;\n    private String OperMethod;\n    private String OperRequParam;\n    private String OperRespParam;\n    private String OperUserId;\n    private String OperUserName;\n    private String OperIp;\n    private String OperUri;\n    private Date OperCreateTime;\n    private String OperVer;\n}\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD) //注解放置的目标位置,METHOD是可注解在方法级别上\n@Retention(RetentionPolicy.RUNTIME) //注解在哪个阶段执行\n@Documented\npublic @interface OperLog {\n    String operModul() default \"\"; // 操作模块\n    String operType() default \"\";  // 操作类型\n    String operDesc() default \"\";  // 操作说明\n}\n```\n\n### controller\n\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/test/{testName}\")\n    @OperLog(operModul = \"测试模块\",operType = \"test\",operDesc = \"这个是用来测试的\")\n    public String test(@PathVariable String testName){\n        return  \"hello\"+testName;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[把自己牛逼到了，在SpringBoot用AOP切面实现一个权限校验...](https://mp.weixin.qq.com/s/2e8x9n4p49kZzM2Fr2cTVw)\n\n[2].[Spring AOP 实现功能权限校验功能](https://blog.csdn.net/houxuehan/article/details/51745175?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&spm=1001.2101.3001.4242)\n\n[3].[SpringAop实现权限校验与日志打印](https://blog.csdn.net/sinat_34620530/article/details/103993158?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control)\n\n[4].[基于Spring AOP实现的权限控制](https://www.cnblogs.com/sxkgeek/p/9985929.html)\n\n[5].[使用SpringBoot AOP 记录操作日志、异常日志](https://www.cnblogs.com/wm-dv/p/11735828.html)\n\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(1)——AOP-2-静态代理与动态代理","url":"/2020/12/29/SpringBoot/SpringBoot系列(1)——AOP-2-静态代理与动态代理/","content":"## 摘要\n\n* 分别演示静态代理和动态代理\n\n<!--more-->\n\n## 静态代理\n\n### 手动代理\n\n#### interface\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 代理类\n\n```java\npublic class Object_Agent implements Interface_{\n\n    private Object_ object_;\n    public Object_Agent(Object_ object_) {\n        this.object_ = object_;\n    }\n\n    @Override\n    public  void do() {\n        System.out.println(\"enhance\");\n        object_.do();\n    }\n    \n    public static void main(String[] args) {\n        Object_ object_ = new Object_();\n        Object_Agent agent = new Object_Agent(object_);\n        agent.do();\n    }\n\n}\n```\n\n\n\n### AspectJ静态\n\n* 编写方式和spring aop没有区别\n\n- Aspectj并不是动态的在运行时生成代理类，而是在编译的时候就植入代码到class文件\n- 由于是静态织入的，所以性能相对来说比较好\n\n\n\n## 动态代理\n\n> * JDK动态代理是基于接口的方式，代理类和目标类都实现同一个接口。\n> * CGLib动态代理是代理类去继承目标类，然后重写其中目标类的方法。\n\n### JDK动态代理\n\n#### 接口\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 处理器实现类\n\n```java\npublic class InvocationHandlerImpl implements InvocationHandler{\n\n    private Object object;\n    public InvocationHandlerImpl(Object object)\n    {\n        this.object = object;\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n    {\n        System.out.println(\"enhance\");\n        Object object = method.invoke(object, args);\n        return object;\n    }\n}\n```\n\n#### 测试\n\n```java\npublic class DynamicProxyDemonstration\n{\n    public static void main(String[] args)\n    {\n        Interface_ object_ = new Object_();\n        InvocationHandler handler = new InvocationHandlerImpl(object_);\n        ClassLoader loader = object_.getClass().getClassLoader();\n        Class[] interfaces = object_.getClass().getInterfaces();\n        Interface_ object__ = (Interface_) Proxy.newProxyInstance(loader, interfaces, handler); \n        object__.do();\n    }\n \n}\n```\n\n\n\n### CGlib动态代理\n\n#### POM\n\n```xml\n<dependency>\n        <groupId>cglib</groupId>\n        <artifactId>cglib</artifactId>\n        <version>2.2.2</version>\n</dependency>\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_{\n    public  void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 方法拦截器\n\n```java\npublic class MyMethodInterceptor implements MethodInterceptor{\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"enhance\");\n        Object object = proxy.invokeSuper(obj, args);\n        return object;\n    }  \n}\n```\n\n#### 测试\n\n```java\npublic class CgLibProxy {\n    public static void main(String[] args) {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer = new Enhancer();\n        //设置目标类的字节码文件\n        enhancer.setSuperclass(Object_.class);\n        //设置回调函数\n        enhancer.setCallback(new MyMethodInterceptor());\n        //创建加运行\n        Object_ proxyObject_ = (Object_)enhancer.create();\n        proxyObject_.do();       \n    }\n}\n```\n\n## 为啥转变被CGlib\n\n一般写代码：\n\n```java\n@Autowired\nUserService userService;\n```\n\n出错代码：\n\n```\n@Autowired\nUserServiceImpl userService;\n```\n\n![启动报错](https://img2018.cnblogs.com/blog/1822265/201910/1822265-20191029133357222-1265293381.png)\n\n JDK 动态代理是基于接口的，代理生成的对象只能赋值给接口变量。\n\n而 CGLIB 就不存在这个问题。因为 CGLIB 是通过生成子类来实现的，代理对象无论是赋值给接口还是实现类这两者都是代理对象的父类。\n\n## 总结\n\n* Spring5 默认aop实现为CGlib\n* JDK动态代理是基于接口的，CGlib动态代理是基于继承的\n\n## 参考\n\n[1].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[2].[java反射和代理](https://www.cnblogs.com/wyq1995/p/10936286.html)\n\n[3].[惊人！Spring5 AOP 默认使用Cglib? 从现象到源码深度分析](https://www.cnblogs.com/coderxiaohei/p/11758239.html)","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(2)——AOP-静态代理与动态代理","url":"/2020/12/29/SpringBoot/SpringBoot系列(2)——AOP-静态代理与动态代理/","content":"## 摘要\n\n* 分别演示静态代理和动态代理\n\n<!--more-->\n\n## 静态代理\n\n### 手动代理\n\n#### interface\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 代理类\n\n```java\npublic class Object_Agent implements Interface_{\n\n    private Object_ object_;\n    public Object_Agent(Object_ object_) {\n        this.object_ = object_;\n    }\n\n    @Override\n    public  void do() {\n        System.out.println(\"enhance\");\n        object_.do();\n    }\n    \n    public static void main(String[] args) {\n        Object_ object_ = new Object_();\n        Object_Agent agent = new Object_Agent(object_);\n        agent.do();\n    }\n\n}\n```\n\n\n\n### AspectJ静态\n\n* 编写方式和spring aop没有区别\n\n- Aspectj并不是动态的在运行时生成代理类，而是在编译的时候就植入代码到class文件\n- 由于是静态织入的，所以性能相对来说比较好\n\n\n\n## 动态代理\n\n> * JDK动态代理是基于接口的方式，代理类和目标类都实现同一个接口。\n> * CGLib动态代理是代理类去继承目标类，然后重写其中目标类的方法。\n\n### JDK动态代理\n\n#### 接口\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 处理器实现类\n\n```java\npublic class InvocationHandlerImpl implements InvocationHandler{\n\n    private Object object;\n    public InvocationHandlerImpl(Object object)\n    {\n        this.object = object;\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n    {\n        System.out.println(\"enhance\");\n        Object object = method.invoke(object, args);\n        return object;\n    }\n}\n```\n\n#### 测试\n\n```java\npublic class DynamicProxyDemonstration\n{\n    public static void main(String[] args)\n    {\n        Interface_ object_ = new Object_();\n        InvocationHandler handler = new InvocationHandlerImpl(object_);\n        ClassLoader loader = object_.getClass().getClassLoader();\n        Class[] interfaces = object_.getClass().getInterfaces();\n        Interface_ object__ = (Interface_) Proxy.newProxyInstance(loader, interfaces, handler); \n        object__.do();\n    }\n \n}\n```\n\n\n\n### CGlib动态代理\n\n#### POM\n\n```xml\n<dependency>\n        <groupId>cglib</groupId>\n        <artifactId>cglib</artifactId>\n        <version>2.2.2</version>\n</dependency>\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_{\n    public  void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 方法拦截器\n\n```java\npublic class MyMethodInterceptor implements MethodInterceptor{\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"enhance\");\n        Object object = proxy.invokeSuper(obj, args);\n        return object;\n    }  \n}\n```\n\n#### 测试\n\n```java\npublic class CgLibProxy {\n    public static void main(String[] args) {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer = new Enhancer();\n        //设置目标类的字节码文件\n        enhancer.setSuperclass(Object_.class);\n        //设置回调函数\n        enhancer.setCallback(new MyMethodInterceptor());\n        //创建加运行\n        Object_ proxyObject_ = (Object_)enhancer.create();\n        proxyObject_.do();       \n    }\n}\n```\n\n## 为啥转变被CGlib\n\n一般写代码：\n\n```java\n@Autowired\nUserService userService;\n```\n\n出错代码：\n\n```\n@Autowired\nUserServiceImpl userService;\n```\n\n![启动报错](https://img2018.cnblogs.com/blog/1822265/201910/1822265-20191029133357222-1265293381.png)\n\n JDK 动态代理是基于接口的，代理生成的对象只能赋值给接口变量。\n\n而 CGLIB 就不存在这个问题。因为 CGLIB 是通过生成子类来实现的，代理对象无论是赋值给接口还是实现类这两者都是代理对象的父类。\n\n## 总结\n\n* Spring5 默认aop实现为CGlib\n* JDK动态代理是基于接口的，CGlib动态代理是基于继承的\n\n## 参考\n\n[1].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[2].[java反射和代理](https://www.cnblogs.com/wyq1995/p/10936286.html)\n\n[3].[惊人！Spring5 AOP 默认使用Cglib? 从现象到源码深度分析](https://www.cnblogs.com/coderxiaohei/p/11758239.html)","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(1)——AOP-1-入门","url":"/2020/12/28/SpringBoot/SpringBoot系列(1)——AOP-1-入门/","content":"\n## 摘要\n\n* aop关键词\n* spring aop小demo\n\n<!--more-->\n\n## 概念\n\n> 使用场景：与业务无关的且经常使用到的公共功能如鉴权，日志，性能优化，事务，错误处理，资源池，同步，审计，幂等等\n\n>  优点：降低耦合度，易扩展，高复用\n>\n>  实现方式：静态代理(AspectJ) + 动态代理（CGlib/Jdk）\n\n### aop关键词\n\n- 连接点(Joinpoint):连接点就是增强的实现\n- 切点(PointCut):就是那些需要应用切面的方法 \n- 增强(Advice)\n  - 前置通知(before)\n  - 后置通知(after)\n  - 异常通知(afterThrowing)\n  - 返回通知(afterReturning)\n  - 环绕通知(around)\n- 目标对象(Target)\n- 织入(Weaving):添加到对目标类具体连接点上的过程。\n- 代理类(Proxy):一个类被AOP织入增强后，就产生了一个代理类。\n- 切面(Aspect):切面由切点和增强组成，它既包括了横切逻辑的定义，也包括了连接点的定义\n  ![](https://gitee.com/BothSavage/PicGo/raw/master/image/20210102170844.png)\n### 五种返回类型\n\n* @Before： 标识一个前置增强方法，相当于BeforeAdvice的功能. \n* @After： final增强，不管是抛出异常或者正常退出都会执行. \n* @AfterReturning： 后置增强，似于AfterReturningAdvice, 方法正常退出时执行.\n*  @AfterThrowing： 异常抛出增强，相当于ThrowsAdvice. @Around： 环绕增强，相当于MethodInterceptor. \n\n### 连接点限制\n\n- 任意公共方法的执行：execution(public * *(..))\n- 任何一个以“set”开始的方法的执行：execution(* set*(..))\n- AccountService 接口的任意方法的执行：execution(* com.xyz.service.AccountService.*(..))\n- 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..))\n- 定义在service包和所有子包里的任意类的任意方法的执行：execution(* com.xyz.service..*.*(..))\n\n- 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：execution(*com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))\")\n- pointcutexp包里的任意类： within(com.test.spring.aop.pointcutexp.*)\n- pointcutexp包和所有子包里的任意类：within(com.test.spring.aop.pointcutexp..*)\n- 实现了Intf接口的所有类,如果Intf不是接口,限定Intf单个类：this(com.test.spring.aop.pointcutexp.Intf)\n- 当一个实现了接口的类被AOP的时候,用getBean方法必须cast为接口类型,不能为该类的类型\n- 带有@Transactional标注的所有类的任意方法： @within(org.springframework.transaction.annotation.Transactional) @target(org.springframework.transaction.annotation.Transactional)\n- 带有@Transactional标注的任意方法：\n  @annotation(org.springframework.transaction.annotation.Transactional)\n  @within和@target针对类的注解,@annotation是针对方法的注解\n- 参数带有@Transactional标注的方法：@args(org.springframework.transaction.annotation.Transactional)\n- 参数为String类型(运行是决定)的方法： args(String)\n\n## Spring aop测试\n\n### pom\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.5.RELEASE</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-aop</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n### aspect\n\n```java\n@Component\n@Aspect \npublic class DemoAspect {\n\n\n    //切入点1：匹配xxx类下的方法名以demo开头、参数类型为int的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo*(int))\")\n    public void matchCondition() {}\n\n    //切入点2：匹配xxx类下的方法名以demo开头、参数类型为long的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo1*(long))\")\n    public void matchCondition_() {}\n\n    //前置\n    @Before(\"matchCondition()\")\n    public void before() {\n        System.out.println(\"Before\");\n    }\n\n    //全局后置\n    @After(\"matchCondition()\")\n    public void after(){\n        System.out.println(\"after\");\n    }\n\n    //返回后置\n    @AfterReturning(\"matchCondition()\")\n    public void afterReturning(){\n        System.out.println(\"afterReturning\");\n    }\n\n    //抛出后置\n    @AfterThrowing(\"matchCondition()\")\n    public void afterThrowing(){\n        System.out.println(\"afterThrowing\");\n    }\n\n    @Around(\"matchCondition_()\")\n    public Object around(ProceedingJoinPoint joinPoint) {\n        Object result = null;\n        System.out.println(\"before\");\n        try{\n            result = joinPoint.proceed(joinPoint.getArgs());//获取参数\n            System.out.println(\"after\");\n        } catch (Throwable e) {\n            System.out.println(\"after exception\");\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"finally\");\n        }\n        return result;\n    }\n\n}\n```\n\n### service\n\n```java\n@Service\npublic class DemoService {\n\n    public void demo(int arg1){\n        System.out.println(arg1);\n    }\n\n    public void demo1(long arg1){\n        System.out.println(arg1);\n    }\n    \n}\n```\n\n\n\n### test\n\n```java\n@SpringBootTest\npublic class DemoServiceTest {\n    \n    @Autowired\n    DemoService demoService;\n\n    //测试单独四个\n    @Test\n    public void testDemo1(){\n        demoService.demo(1);\n    }\n    \n    //测试around\n    @Test\n    public void testDemo2(){\n        demoService.demo1(1L);\n    }\n}\n```\n\n## 参考\n\n[1].[Spring AOP——简单粗暴，小白教学](https://blog.csdn.net/qq_41981107/article/details/87920537)\n\n[2].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[3].[关于 Spring AOP (AspectJ) 你该知晓的一切](https://zhuanlan.zhihu.com/p/25522841)\n\n[4].[Spring AOP用法详解](https://www.cnblogs.com/liantdev/p/10125284.html)\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(1)——AOP-入门","url":"/2020/12/28/SpringBoot/SpringBoot系列(1)——AOP-入门/","content":"\n## 摘要\n\n* aop关键词\n* spring aop小demo\n\n<!--more-->\n\n## 概念\n\n> 使用场景：与业务无关的且经常使用到的公共功能如鉴权，日志，性能优化，事务，错误处理，资源池，同步，审计，幂等等\n\n>  优点：降低耦合度，易扩展，高复用\n>\n>  实现方式：静态代理(AspectJ) + 动态代理（CGlib/Jdk）\n\n### aop关键词\n\n- 连接点(Joinpoint):连接点就是增强的实现\n- 切点(PointCut):就是那些需要应用切面的方法 \n- 增强(Advice)\n  - 前置通知(before)\n  - 后置通知(after)\n  - 异常通知(afterThrowing)\n  - 返回通知(afterReturning)\n  - 环绕通知(around)\n- 目标对象(Target)\n- 织入(Weaving):添加到对目标类具体连接点上的过程。\n- 代理类(Proxy):一个类被AOP织入增强后，就产生了一个代理类。\n- 切面(Aspect):切面由切点和增强组成，它既包括了横切逻辑的定义，也包括了连接点的定义\n  ![](https://gitee.com/BothSavage/PicGo/raw/master/image/20210102170844.png)\n### 五种返回类型\n\n* @Before： 标识一个前置增强方法，相当于BeforeAdvice的功能. \n* @After： final增强，不管是抛出异常或者正常退出都会执行. \n* @AfterReturning： 后置增强，似于AfterReturningAdvice, 方法正常退出时执行.\n*  @AfterThrowing： 异常抛出增强，相当于ThrowsAdvice. @Around： 环绕增强，相当于MethodInterceptor. \n\n### 连接点限制\n\n- 任意公共方法的执行：execution(public * *(..))\n- 任何一个以“set”开始的方法的执行：execution(* set*(..))\n- AccountService 接口的任意方法的执行：execution(* com.xyz.service.AccountService.*(..))\n- 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..))\n- 定义在service包和所有子包里的任意类的任意方法的执行：execution(* com.xyz.service..*.*(..))\n\n- 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：execution(*com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))\")\n- pointcutexp包里的任意类： within(com.test.spring.aop.pointcutexp.*)\n- pointcutexp包和所有子包里的任意类：within(com.test.spring.aop.pointcutexp..*)\n- 实现了Intf接口的所有类,如果Intf不是接口,限定Intf单个类：this(com.test.spring.aop.pointcutexp.Intf)\n- 当一个实现了接口的类被AOP的时候,用getBean方法必须cast为接口类型,不能为该类的类型\n- 带有@Transactional标注的所有类的任意方法： @within(org.springframework.transaction.annotation.Transactional) @target(org.springframework.transaction.annotation.Transactional)\n- 带有@Transactional标注的任意方法：\n  @annotation(org.springframework.transaction.annotation.Transactional)\n  @within和@target针对类的注解,@annotation是针对方法的注解\n- 参数带有@Transactional标注的方法：@args(org.springframework.transaction.annotation.Transactional)\n- 参数为String类型(运行是决定)的方法： args(String)\n\n## Spring aop测试\n\n### pom\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.5.RELEASE</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-aop</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n### aspect\n\n```java\n@Component\n@Aspect \npublic class DemoAspect {\n\n\n    //切入点1：匹配xxx类下的方法名以demo开头、参数类型为int的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo*(int))\")\n    public void matchCondition() {}\n\n    //切入点2：匹配xxx类下的方法名以demo开头、参数类型为long的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo1*(long))\")\n    public void matchCondition_() {}\n\n    //前置\n    @Before(\"matchCondition()\")\n    public void before() {\n        System.out.println(\"Before\");\n    }\n\n    //全局后置\n    @After(\"matchCondition()\")\n    public void after(){\n        System.out.println(\"after\");\n    }\n\n    //返回后置\n    @AfterReturning(\"matchCondition()\")\n    public void afterReturning(){\n        System.out.println(\"afterReturning\");\n    }\n\n    //抛出后置\n    @AfterThrowing(\"matchCondition()\")\n    public void afterThrowing(){\n        System.out.println(\"afterThrowing\");\n    }\n\n    @Around(\"matchCondition_()\")\n    public Object around(ProceedingJoinPoint joinPoint) {\n        Object result = null;\n        System.out.println(\"before\");\n        try{\n            result = joinPoint.proceed(joinPoint.getArgs());//获取参数\n            System.out.println(\"after\");\n        } catch (Throwable e) {\n            System.out.println(\"after exception\");\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"finally\");\n        }\n        return result;\n    }\n\n}\n```\n\n### service\n\n```java\n@Service\npublic class DemoService {\n\n    public void demo(int arg1){\n        System.out.println(arg1);\n    }\n\n    public void demo1(long arg1){\n        System.out.println(arg1);\n    }\n    \n}\n```\n\n\n\n### test\n\n```java\n@SpringBootTest\npublic class DemoServiceTest {\n    \n    @Autowired\n    DemoService demoService;\n\n    //测试单独四个\n    @Test\n    public void testDemo1(){\n        demoService.demo(1);\n    }\n    \n    //测试around\n    @Test\n    public void testDemo2(){\n        demoService.demo1(1L);\n    }\n}\n```\n\n## 参考\n\n[1].[Spring AOP——简单粗暴，小白教学](https://blog.csdn.net/qq_41981107/article/details/87920537)\n\n[2].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[3].[关于 Spring AOP (AspectJ) 你该知晓的一切](https://zhuanlan.zhihu.com/p/25522841)\n\n[4].[Spring AOP用法详解](https://www.cnblogs.com/liantdev/p/10125284.html)\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"Gitee图床+typora&notion+snipaste","url":"/2020/12/26/杂项/Gitee图床+typora&notion+snipaste/","content":"## 摘要\n* 软件的下载地址\n* 配置PicGo图床，把gitee作为图床\n* markdown软件typora，notion1简介\n* 截图软件snipaste快速配合PicGo\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 软件下载\n\n> [1].[图床软件PicGo](https://molunerfinn.com/PicGo/)\n>\n> [2].[typota](https://typora.io/)\n>\n> [3].[notion](https://www.notion.so/)\n>\n> [4].[snipaste](https://www.snipaste.com/)\n\n## 使用\n\n### typora,notion\n\ntypora和notion都是支持Markdown语法的文档编辑器，但是notion支持更多的功能，比如生成如下形式的文档\n\n![](https://gitee.com/BothSavage/PicGo/raw/master/image/20201226130027.png)\n\n### picgo\n\n所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 `Electron-vue` 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用\n\n> 推荐使用gitee，因为github访问不稳定\n\n- 直接搜索gitee在PicG的插件界面，安装picgo-plugin-gitee-uploader\n- 对应填好如下属性\n\n- - 其中repo为**用户名/仓库名**\n  - branch默认为master\n  - token的获取方法在下面\n  - path为子文件为目录\n\n- ![](https://gitee.com/BothSavage/PicGo/raw/master/image/1602233669972-05e582dc-5379-4b2b-ac8d-4ecb1789093c.png)\n\n### snipaste\n\n这是一款强大的截图工具，默认热键为F1，截图完成后点击右下角复制到剪切板，再使用图床的默认热键，快速完成图片上传\n\n![](https://gitee.com/BothSavage/PicGo/raw/master/image/20201226131235.png)\n\n## 参考\n\n[1].[Typora 完全使用详解](https://sspai.com/post/54912/)\n\n[2].[PicGo图床使用](https://www.yuque.com/u2063760/xbfae1/mipufs)\n\n\n\n\n\n","tags":["工具","git","图床"],"categories":["杂项"]},{"title":"Hexo结合Stun静态博客搭建从入门到入土","url":"/2020/12/19/杂项/Hexo结合Stun静态博客搭建从入门到入土 - 副本/","content":"## 摘要\n* 安装npm，安装hexo相关依赖，安装主题stun\n* 修改hexo配置，修改stun配置，部署到github，gitee实现静态访问\n* 给博客加上全局搜索，访问量统计\n* hexo博客编写模板\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 搭建环境\n\n### 创建仓库\n\n1.github\n\n> 仓库命名为：{$你的ID}.github.io\n\n2.gitee\n\n> 仓库命名为：{$你的ID}  \n\n***仓库名大小写一致，访问路径也是***\n\n### 环境安装\n\n1.安装npm\n\n> https://nodejs.org/en/download/\n\n2.安装cnpm\n\n```\nnpm install cnpm\n```\n\n3.安装博客搭建框架hexo\n\n```\ncnpm install -g hexo-cli\n```\n\n4.新建一个文件夹，并且之后所有操作都基于该文件夹\n\n```\nmkdir {$xxx}\ncd {$xxx}\n```\n\n5.安装依赖，下载主题\n\n```\ncnpm install --save hexo-deployer-git \ncnpm install --save hexo-render-pug\ncnpm install --save hexo-generator-search \ngit clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n```\n\n6.增加页面导航\n\n```\nhexo new page categories\nhexo new page tags\n```\n\n> 项目目录/source/categories/index.md  加上\n>\n> ```\n> type: categories\n> ```\n>\n> 项目目录/source/tags/index.md  加上\n>\n> ```\n> type: tags\n> ```\n\n### 修改配置文件\n\n1.修改部署文件夹下/_config.yml（挑选重要部分修改）\n\n```\n#展示设置\ntitle: {$自定义文字}\nlanguage: zh-CN \nurl: {$博客地址}\n\n#主题\ntheme: stun\n\n#git相关\ndeploy:\n  type: git\n  repo: \n  \tgithub: {$你的博客仓库}\n  \tgitee: {$你的博客仓库}\n  branch: master\n\n#搜索相关\nsearch:\n  path: search.json\n  field: post\n  content: true\n```\n\n2.修改部署文件夹下/themes/stun/_config.yml(挑选重要部分修改)\n\n```\n#取消导航栏注释（注意空格对齐）\nmenu:\n  categories: /categories/ || fas fa-layer-group\n  tags: /tags/ || fas fa-tags\n  \n#更改图标(最好使用链接地址，我这里使用的图床，图床使用见下一篇博客)\nfavicon:\n  small: https://gitee.com/BothSavage/PicGo/raw/master/image/favicon-16x16.png\n  medium: https://gitee.com/BothSavage/PicGo/raw/master/image/favicon-32x32.png\n\n#更改背景大图\nheader:\n  bg_image:\n    enable: true\n    url: https://gitee.com/BothSavage/PicGo/raw/master/image/背景.png\n\n#更改头像大图，并设为圆形\nauthor:\n  avatar:\n    url: https://gitee.com/BothSavage/PicGo/raw/master/image/头像.png\n    rounded: true\n    \n#打开访问统计\nbusuanzi:\n  enable: true\n  \n#打开搜索功能\nlocal_search:\n  enable: true\n\n```\n\n### 运行\n\n1.基础命令\n\n```\nhexo c  #清理一下\nhexo g  #生成\nhexo s  #部署到本地4000端口\nhexo d  #部署到远程Github仓库\n```\n\n2.推荐命令\n\n```\n#第一次尝试本地是否能访问\nhexo c  && hexo g && hexo s\n#以后每次添加文章\nhexo c  && hexo g && hexo d\n```\n\n### 博客文件存放地点\n\n> 项目目录/source/_posts\n\n## markdown文件规范\n\n1.文章元数据\n\n```\n#分别指定文章标题，时间，类别，标签\n---\ntitle: Hexo结合Stun静态博客搭建从入门到入土\ndate: 2020-12-19  20:40:11\ncategories:\n- 杂项\ntags:\n- 前端\n- 建站\n---\n```\n\n2.主页不显示文章全部\n\n```\n 上面是显示内容\n <!--more--> \n```\n\n## 其他高级功能\n\nstun主题支持\n\n* 评论系统\n* 站长工具\n* 数据公式\n* 网站特效\n* ................\n\n详情请查看\n\nhttps://theme-stun.github.io/docs/zh-CN/\n\n## 参考\n\n[1].[菜鸟教程：NodeJS安装配置](https://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n[2].[Stun主题指南](https://theme-stun.github.io/docs/zh-CN/)\n\n[3].[静态博客搭建](https://www.yuque.com/u2063760/xbfae1/gf45k1)\n\n[4].[_more截断文章_多标签添加](https://blog.csdn.net/Aoman_Hao/article/details/79291741)\n\n[5].[在gitee上部署静态网站（或者个人博客）](https://blog.csdn.net/zhangyu4863/article/details/80473412)\n\n","tags":["前端","建站"],"categories":["杂项"]},{"title":"设计模式(10)-装饰模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(10)-装饰模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(11)-外观模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(11)-外观模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(8)-适配器模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(12)-享元模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(13)-组合模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(13)-组合模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(7)-代理模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(7)-代理模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(8)-适配器模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(8)-适配器模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(9)-桥接模式","url":"/2020/01/04/设计模式/结构型模式/设计模式(9)-桥接模式/","content":"## 摘要\n\n* \n  <!--more-->\n## 场景\n\n两个对象因**接口不兼容**而不能在一起工作的实例，这时需要第三者进行**适配**\n\n* USB转HDMI接口，此时转接头就是适配器\n* 翻译官是适配器\n\n## 概念\n\n> 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 优点\n\n* 客户端通过适配器可以透明地调用目标接口。\n* 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。\n* 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。\n* 在很多业务场景中符合开闭原则。\n\n### 缺点\n\n* 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。\n* 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 模式的结构与实现\n\n> \n\n## 实例\n\n\n\n## 参考\n\n[1].[适配器模式（Adapter模式）详解](http://c.biancheng.net/view/1361.html)\n\n","tags":["demo","设计模式","代理模式","适配器模式"],"categories":["设计模式"]},{"title":"设计模式(15)-策略模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(15)-策略模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(16)-命令模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(16)-命令模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(17)-责任链模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(17)-责任链模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(18)-状态模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(18)-状态模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(19)-观察者模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(19)-观察者模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(20)-中介者模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(20)-中介者模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(21)-迭代器模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(21)-迭代器模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(14)-模板方法模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(14)-模板方法模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(22)-访问者模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(22)-访问者模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(23)-备忘录模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(23)-备忘录模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"设计模式(24)-解释器模式","url":"/2020/01/04/设计模式/行为型模式/设计模式(24)-解释器模式/","content":"## 摘要\n\n* 代理模式的优点\n* 代理模式的小demo\n<!--more-->\n## 场景\n\n客户不能直接去访问一个对象，需要一个**中介**帮忙完成某项任务，这个对象就是代理对象。\n\n* 去12306买火车票，那么12306应用就是代理对象\n* 在上谷歌的时候用的梯子，梯子就是代理对象\n* 点外卖的时候，外卖平台就是代理对象\n\n## 概念\n\n> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n### 优点\n\n* 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n* 代理对象可以扩展目标对象的功能；\n* 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\n\n### 缺点\n\n* 代理模式会造成系统设计中类的数量增加\n* 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n* 增加了系统的复杂度\n\n> 使用动态代理可以缓解部分去缺点\n\n### 主要角色\n\n1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 静态代理和动态代理\n\n在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\n\n根据代理的创建时期，代理模式分为静态代理和动态代理。\n\n- 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。\n- 动态：在程序运行时，运用反射机制动态创建而成\n\n## 实例\n\n### 抽象主题\n\n```java\ninterface Subject {\n    void Request();\n}\n```\n\n### 真实主题\n\n```java\nclass RealSubject implements Subject {\n    public void Request() {\n        System.out.println(\"访问真实主题方法...\");\n    }\n}\n```\n\n### 代理\n\n```java\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        preRequest();\n        realSubject.Request();\n        postRequest();\n    }\n\n    public void preRequest() {\n        System.out.println(\"访问真实主题之前的预处理。\");\n    }\n\n    public void postRequest() {\n        System.out.println(\"访问真实主题之后的后续处理。\");\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[代理模式（代理设计模式）详解](http://c.biancheng.net/view/1359.html)\n\n","tags":["demo","设计模式","代理模式","动态代理"],"categories":["设计模式"]},{"title":"Hello World","url":"/1920/06/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]